<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温治康</title>
  <subtitle>nice man</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://startwithwzk.github.io/"/>
  <updated>2017-08-03T15:26:33.724Z</updated>
  <id>https://startwithwzk.github.io/</id>
  
  <author>
    <name>温治康</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lambda-Java8</title>
    <link href="https://startwithwzk.github.io/2017/08/03/Lambda-Java8/"/>
    <id>https://startwithwzk.github.io/2017/08/03/Lambda-Java8/</id>
    <published>2017-08-03T15:25:05.000Z</published>
    <updated>2017-08-03T15:26:33.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda-Java-8"><a href="#Lambda-Java-8" class="headerlink" title="Lambda-Java 8"></a>Lambda-Java 8</h1><blockquote>
<p>Lambda ����ʽ��һ����������(�� Java �����Ⲣ����ȫ��ȷ�������ڹ�����ô��Ϊ)���򵥵�˵������û�������ķ�����Ҳ��û�з������η�������ֵ���������֡�</p>
<p>�����Խ�������һ���ټǣ�������Ҫʹ��ĳ�������ĵط�д��������ĳ������ֻʹ��һ�Σ����Ҷ����ܼ��̣�ʹ�������ټ�����֮������Ч�����������Ͳ��������з���д�����뷽���ˡ�</p>
</blockquote>
<p>Java�е�Lambda����ʽͨ��ʹ��(argument) -&gt; {body}�﷨��д�����磺</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(arg1, arg2...) -&gt; &#123; body &#125;</div><div class="line"></div><div class="line">(type1 arg1, type2 arg2...) -&gt; &#123; body &#125;</div><div class="line"></div><div class="line"><span class="comment">// example</span></div><div class="line"></div><div class="line">() -&gt; System.out.println(<span class="string">"Hello World"</span>)</div><div class="line"></div><div class="line">(String s) -&gt; &#123; System.out.println(s); &#125;</div><div class="line"></div><div class="line">System.out::println</div><div class="line"></div><div class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;  <span class="keyword">return</span> a + b; &#125;</div><div class="line"></div><div class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;</div><div class="line"></div><div class="line">() -&gt; <span class="number">42</span></div></pre></td></tr></table></figure>
<p>����֮�⻹�� ����::����������ʽ�����磺</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ����ʽ</span></div><div class="line">person -&gt; person.getAge();</div><div class="line"><span class="comment">// �����滻��</span></div><div class="line">Person::getAge</div><div class="line"><span class="comment">// ����ʽ</span></div><div class="line">() -&gt; <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="comment">// �����滻��</span></div><div class="line">HashMap::<span class="keyword">new</span></div></pre></td></tr></table></figure>
<p>����<strong>��������</strong>����˵<strong>˫ð������</strong>��Ӧ�Ĳ���������<code>Function&lt;T, R&gt;</code>��T��ʾ�������ͣ�R��ʾ�������͡���������ʽ<code>person -&gt; person.getAge()</code> ����������person������ֵ��<code>person.getAge()</code>����ô��������<code>Person::getAge</code>�Ͷ�Ӧ��<code>Function&lt;Person, Integer&gt;</code>���͡�</p>
<h2 id="Lambda����ʽ�Lu"><a href="#Lambda����ʽ�Lu" class="headerlink" title="Lambda����ʽ�Ľṹ"></a>Lambda����ʽ�Ľṹ</h2><ul>
<li>һ�� Lambda ����ʽ��������������������</li>
<li>���������ͼȿ�����ȷ������Ҳ���Ը������������ƶϡ����磺<code>(int a)</code>��<code>(a)</code>Ч����ͬ</li>
<li>���в�����������Բ�����ڣ�����֮���ö������������磺<code>(a, b)</code> �� <code>(int a, int b)</code>�� <code>(String a, int b, float c)</code></li>
<li>��Բ���Ŵ���������Ϊ�ա����磺<code>() -&gt; 42</code></li>
<li>��ֻ��һ���������������Ϳ��Ƶ�ʱ��Բ���ţ�����ʡ�ԡ����磺<code>a -&gt; return a*a</code></li>
<li>Lambda ����ʽ�������ɰ�����������������</li>
<li>���� Lambda ����ʽ������ֻ��һ�����䣬������{}��ʡ�ԡ����������ķ�������������������ʽһ��</li>
<li>���� Lambda ����ʽ����������һ���������䣬������ʽ���������ڻ�����{}�У��γɴ����飩�����������ķ����������������ķ�������һ�£���û�з�����Ϊ��</li>
</ul>
<h2 id="ʲo�A���ʽ�ӿ�"><a href="#ʲo�A���ʽ�ӿ�" class="headerlink" title="ʲô�Ǻ���ʽ�ӿ�"></a>ʲô�Ǻ���ʽ�ӿ�</h2><p>�� Java �У�Marker�����ǣ����͵Ľӿ���һ��û�з��������������Ľӿڣ��򵥵�˵��marker �ӿ��ǿսӿڡ����Ƶأ�����ʽ�ӿ���ֻ����һ�����󷽷������Ľӿڡ�</p>
<p><code>java.lang.Runnable</code> ����һ�ֺ���ʽ�ӿڣ��� Runnable �ӿ���ֻ������һ������ <code>void run()</code>�����Ƶأ�<code>OnClickListener</code> �ӿ�Ҳ��һ�ֺ���ʽ�ӿڣ�����ʹ�������ڲ�����ʵ��������ʽ�ӿڵĶ��������� Lambda ����ʽ����һ��ʽ���Եõ��򻯡�</p>
<p>@FunctionalInterface�� Java 8 �¼�����һ�ֽӿڣ�����ָ���ýӿ����������Ǹ��� Java ���Թ淶�����ĺ���ʽ�ӿڡ�Java 8 ��������һЩ Lambda ����ʽ����ʹ�õĺ���ʽ�ӿڣ�����ע�͵Ľӿڲ�����Ч�ĺ���ʽ�ӿ�ʱ������ʹ�� @FunctionalInterface �������������Ĵ�����</p>
<p>������һ���Զ����ĺ���ʽ�ӿڣ� </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</div><div class="line">  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>���ݶ��壬����ʽ�ӿ�ֻ����һ�����󷽷��������㳢�����ӵڶ������󷽷������׳�����ʱ������</p>
<p>���磺</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeMoreWork</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>������</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Unexpected <span class="meta">@FunctionalInterface</span> annotation </div><div class="line">    <span class="meta">@FunctionalInterface</span> ^ WorkerInterface is not a functional <span class="class"><span class="keyword">interface</span> <span class="title">multiple</span> </span></div><div class="line">    <span class="title">non</span>-<span class="title">overriding</span> <span class="title">abstract</span> <span class="title">methods</span> <span class="title">found</span> <span class="title">in</span> <span class="title">interface</span> <span class="title">WorkerInterface</span> 1 <span class="title">error</span></div></pre></td></tr></table></figure>
<h2 id="Lambda-����ʽ����"><a href="#Lambda-����ʽ����" class="headerlink" title="Lambda ����ʽ����"></a>Lambda ����ʽ����</h2><p>ѧϰ Lambda ����ʽ�����÷�ʽ��ѧϰ���ӡ�</p>
<p>�߳̿���ͨ�����·�����ʼ����</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//�ɷ���:</span></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Hello from thread"</span>);</div><div class="line">&#125;</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line"><span class="comment">//�·���:</span></div><div class="line"><span class="keyword">new</span> Thread(</div><div class="line">() -&gt; System.out.println(<span class="string">"Hello from thread"</span>)</div><div class="line">).start();</div></pre></td></tr></table></figure>
<p>�¼���������ʹ�� Java 8 �� Lambda ����ʽ�����������Ĵ����У����ǽ�ʹ���¾����ַ�ʽ��һ�� Android UI �������� ActionListener��</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Old way:</span></div><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">    Log.i(TAG, <span class="string">"onClick: Lambda"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//New way:</span></div><div class="line">mTextView.setOnClickListener(v -&gt; Log.i(TAG, <span class="string">"onClick: Lambda"</span>));</div></pre></td></tr></table></figure>
<p>���´����������Ǵ�ӡ�����������е�����Ԫ�ء�ע�⣬ʹ�� Lambda ����ʽ�ķ�����ֹһ�֡��������������У����������ó��õļ�ͷ�﷨���� Lambda ����ʽ��֮����ʹ�� Java 8 ȫ�µ�˫ð��(::)��������һ�����淽��ת��Ϊ Lambda ����ʽ��</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Old way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</div><div class="line"><span class="keyword">for</span>(Integer n: list) &#123;</div><div class="line">   System.out.println(n);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//New way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</div><div class="line">list.forEach(n -&gt; System.out.println(n));</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//or we can use :: double colon operator in Java 8</span></div><div class="line">list.forEach(System.out::println);</div></pre></td></tr></table></figure>
<p>�������������У�����ʹ�ö���(Predicate)����ʽ�ӿڴ���һ�����ԣ�����ӡ����ͨ�����Ե�Ԫ�أ����������Ϳ���ʹ�� Lambda ����ʽ�涨һЩ�߼������Դ�Ϊ����������Ϊ��</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Print all numbers: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> </div><div class="line">Print no numbers: </div><div class="line">Print even numbers: <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> </div><div class="line">Print odd numbers: <span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> </div><div class="line">Print numbers greater than <span class="number">5</span>: <span class="number">6</span> <span class="number">7</span></div></pre></td></tr></table></figure>
<p>����������ʹ�� Lambda ����ʽ��ӡ��ֵ��ÿ��Ԫ�ص�ƽ����ע������ʹ���� .stream() ��������������ת��Ϊ����Java 8 ������һЩ�������� APIs��<a href="http://download.java.net/jdk8/docs/api/java/util/stream/Stream.html" target="_blank" rel="external">java.util.stream.Stream</a> �ӿڰ����������õķ������ܽ��� Lambda ����ʽ����������Ч�������ǽ� Lambda ����ʽ <code>x -&gt; x * x</code> ���� map() �������÷��������������е�����Ԫ�ء�֮��������ʹ�� forEach ������ӡ�����е�����Ԫ�أ�</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Old way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">for</span>(Integer n : list) &#123;</div><div class="line">    <span class="keyword">int</span> x = n * n;</div><div class="line">    System.out.println(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//New way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</div><div class="line">list.stream().map(x -&gt; x * x).forEach(System.out::println);</div></pre></td></tr></table></figure>
<p>���������ӻ�����������ֵ��ÿ��Ԫ��ƽ�������ܺ͡���ע�⣬Lambda ����ʽֻ��һ���������ܴﵽ�˹��ܣ���Ҳ�� MapReduce ��һ���������ӡ�����ʹ�� map() ��ÿ��Ԫ����ƽ������ʹ�� reduce() ������Ԫ�ؼ���һ����ֵ��</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Old way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(Integer n : list) &#123;</div><div class="line">    <span class="keyword">int</span> x = n * n;</div><div class="line">    sum = sum + x;</div><div class="line">&#125;</div><div class="line">System.out.println(sum);</div><div class="line"></div><div class="line"><span class="comment">//New way:</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</div><div class="line"><span class="keyword">int</span> sum = list.stream().map(x -&gt; x * x).reduce((x,y) -&gt; x + y).get();</div><div class="line">System.out.println(sum);</div></pre></td></tr></table></figure>
<h2 id="Lambda-����ʽ��������������"><a href="#Lambda-����ʽ��������������" class="headerlink" title="Lambda ����ʽ��������������"></a>Lambda ����ʽ��������������</h2><p>ʹ���������� Lambda ����ʽ��һ���������ڹؼ��ʵ�ʹ�á����������࣬�ؼ��� <code>this</code> ����Ϊ�����࣬������ Lambda ����ʽ���ؼ��� <code>this</code> ����Ϊд�� Lambda ���ⲿ�ࡣ</p>
<h2 id="�ο�"><a href="#�ο�" class="headerlink" title="�ο�"></a>�ο�</h2><p><a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="external">����ǳ�� Java 8 Lambda ����ʽ</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lambda-Java-8&quot;&gt;&lt;a href=&quot;#Lambda-Java-8&quot; class=&quot;headerlink&quot; title=&quot;Lambda-Java 8&quot;&gt;&lt;/a&gt;Lambda-Java 8&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Lambda ����ʽ�
    
    </summary>
    
    
      <category term="Java" scheme="https://startwithwzk.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap的加载和Cache</title>
    <link href="https://startwithwzk.github.io/2017/07/25/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/"/>
    <id>https://startwithwzk.github.io/2017/07/25/第十二章 Bitmap的加载和Cache/</id>
    <published>2017-07-25T11:16:31.000Z</published>
    <updated>2017-07-25T11:25:00.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12-1-Bitmap的高效加载"><a href="#12-1-Bitmap的高效加载" class="headerlink" title="12.1 Bitmap的高效加载"></a>12.1 Bitmap的高效加载</h2><ul>
<li><p><code>BitmapFactory</code>类提供了四类方法：<code>decodeFile</code>、<code>decodeResource</code>、<code>decodeStream</code>和<code>decodeByteArray</code>从不同来源加载出一个Bitmap对象，最终的实现是在底层实现的。</p>
</li>
<li><p>采用<code>BitmapFactory.Options</code>按照一定的采样率来加载所需尺寸的图片，因为iamgeView所需的图片大小往往小于图片的原始尺寸。</p>
</li>
<li><p>常用的获取采样率的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</div><div class="line">    <span class="comment">// First decode with inJustDecodeBounds=true to check dimensions</span></div><div class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</div><div class="line">    BitmapFactory.decodeResource(res, resId, options);</div><div class="line"></div><div class="line">    <span class="comment">// Calculate inSampleSize</span></div><div class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</div><div class="line"></div><div class="line">    <span class="comment">// Decode bitmap with inSampleSize set</span></div><div class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(BitmapFactory.Options options, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (reqWidth == <span class="number">0</span> || reqHeight == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Raw height and width of image</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</div><div class="line">    Log.d(TAG, <span class="string">"origin, w= "</span> + width + <span class="string">" h="</span> + height);</div><div class="line">    <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height / <span class="number">2</span>;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Calculate the largest inSampleSize value that is a power of 2 and</span></div><div class="line">        <span class="comment">// keeps both height and width larger than the requested height and width.</span></div><div class="line">        <span class="keyword">while</span> ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123;</div><div class="line">            inSampleSize *= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Log.d(TAG, <span class="string">"sampleSize:"</span> + inSampleSize);</div><div class="line">    <span class="keyword">return</span> inSampleSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="12-2-Android中的缓存策略"><a href="#12-2-Android中的缓存策略" class="headerlink" title="12.2 Android中的缓存策略"></a>12.2 Android中的缓存策略</h2><ol>
<li><p>最常用的缓存算法是LRU，核心是当缓存满时，会优先淘汰那些近期最少使用的缓存对象，系统中采用LRU算法的缓存有两种：<code>LruCache</code>(内存缓存)和<code>DiskLruCache</code>(磁盘缓存)。</p>
</li>
<li><p>LruCache是Android 3.1才有的，通过support-v4兼容包可以兼容到早期的Android版本。LruCache类是一个线程安全的泛型类，它内部采用一个LinkedHashMap以强引用的方式存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LruCache会移除较早使用的缓存对象，然后再添加新的缓存对象。</p>
</li>
<li><p>一些特殊情况下，还需要重写LruCache的entryRemoved方法，LruCache移除就缓存时会调用entryRemoved</p>
</li>
<li><p>DiskLruCache磁盘缓存，它不属于Android sdk的一部分，它的源码可以在这里下载 DiskLruCache的创建、缓存查找和缓存添加操作</p>
</li>
</ol>
<h2 id="12-3-ImageLoader的使用"><a href="#12-3-ImageLoader的使用" class="headerlink" title="12.3 ImageLoader的使用"></a>12.3 ImageLoader的使用</h2><p>参考源码<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_12/src/com/ryg/chapter_12/loader/ImageLoader.java" target="_blank" rel="external">ImageLoder</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;12-1-Bitmap的高效加载&quot;&gt;&lt;a href=&quot;#12-1-Bitmap的高效加载&quot; class=&quot;headerlink&quot; title=&quot;12.1 Bitmap的高效加载&quot;&gt;&lt;/a&gt;12.1 Bitmap的高效加载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Android的线程和线程池</title>
    <link href="https://startwithwzk.github.io/2017/07/25/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://startwithwzk.github.io/2017/07/25/第十一章 Android的线程和线程池/</id>
    <published>2017-07-25T11:16:20.000Z</published>
    <updated>2017-07-25T11:25:32.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-1-主线程和子线程"><a href="#11-1-主线程和子线程" class="headerlink" title="11.1 主线程和子线程"></a>11.1 主线程和子线程</h2><ol>
<li><p>在Java中默认情况下一个进程只有一个线程，也就是主线程，其他线程都是子线程。Android中的主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。</p>
</li>
<li><p>在Android中除了Thread，还有<code>HandlerThread</code>、<code>AsyncTask</code>以及<code>IntentService</code>等也都扮演着线程的角色。<code>AsyncTask</code>封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。<code>HandlerThread</code>是一种具有消息循环的线程，在它的内部可以使用Handler。<code>IntentService</code>是一个服务，它内部采用HandlerThread来执行任务，当任务执行完毕后就会自动退出。因为它是服务的缘故，所以和后台线程相比，它比较不容易被系统杀死。</p>
</li>
<li><p>从Android3.0开始，系统要求网络访问必须要在子线程中进行，否则网络访问将会失败并抛出<code>NetWorkOnMainThreadException</code>这个异常。</p>
</li>
<li><p>AsyncTask是一个抽象泛型类，它提供了<code>Params</code>、<code>Progress</code>、<code>Result</code>三个泛型参数，如果task确实不需要传递具体的参数，那么都可以设置为<code>void</code>。下面是它的四个核心方法，其中<code>doInBackground</code>不是在主线程执行的。<code>onPreExecute、doInBackground、onProgressUpdate、onPostResult</code></p>
</li>
</ol>
<h2 id="11-2-Android中的线程形态"><a href="#11-2-Android中的线程形态" class="headerlink" title="11.2 Android中的线程形态"></a>11.2 Android中的线程形态</h2><h3 id="11-2-1-AsyncTask"><a href="#11-2-1-AsyncTask" class="headerlink" title="11.2.1 AsyncTask"></a>11.2.1 AsyncTask</h3><h4 id="AsyncTask使用限制"><a href="#AsyncTask使用限制" class="headerlink" title="AsyncTask使用限制"></a>AsyncTask使用限制</h4><ol>
<li>AsyncTask的类必须要在主线程中加载，这个过程在Android4.1以上版本已经被系统自动完成。</li>
<li>AsyncTask的对象必须在主线程中创建，<code>execute</code>方法必须要在UI线程中调用，并且只能执行一次，否则会报运行时异常。</li>
<li>在Android 1.6之前，AsyncTask是<strong>串行执行任务的</strong>，Android1.6的时候AsyncTask开始采用线程池并行处理任务，但是从Android3.0开始，为了避免AsyncTask带来的并发错误，AsyncTask又采用一个线程来串行执行任务。==尽管如此，在Android3.0以及后续版本中，我们可以使用AsyncTask的executeOnExecutor方法来并行执行任务。但是这个方法是Android3.0新添加的方法，并不能在低版本上使用。==</li>
</ol>
<h4 id="AsyncTask的原理"><a href="#AsyncTask的原理" class="headerlink" title="AsyncTask的原理"></a>AsyncTask的原理</h4><ol>
<li><p>AsyncTask中有两个线程池：<code>SerialExecutor</code>和<code>THREAD_POOL_EXECUTOR</code>。前者是用于任务的排队，<strong>默认是串行的线程池</strong>；后者用于真正执行任务。AsyncTask中还有一个Handler，即InternalHandler，用于将执行环境从线程池切换到主线程。AsyncTask内部就是通过InternalHandler来发送任务执行的进度以及执行结束等消息。</p>
</li>
<li><p>AsyncTask排队执行过程：系统先把参数<code>Params</code>封装为<code>FutureTask</code>对象，它相当于Runnable；接着将FutureTask交给SerialExecutor的<code>execute</code>方法，它先把FutureTask插入到任务队列tasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会执行下一个AsyncTask任务，同时当一个AsyncTask任务执行完毕之后，AsyncTask会继续执行其他任务直到所有任务都被执行为止。 </p>
</li>
</ol>
<h3 id="11-2-2-HandlerThread"><a href="#11-2-2-HandlerThread" class="headerlink" title="11.2.2 HandlerThread"></a>11.2.2 HandlerThread</h3><ul>
<li><code>HandlerThread</code>就是一种可以使用Handler的Thread，它的实现就是在run方法中通过<code>Looper.prepare()</code>来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了，外界可以通过Handler的消息方式通知HandlerThread执行一个具体的任务。HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread的时候，可以通过它的<code>quit</code>或者<code>quitSafely</code>方法来终止线程的执行。HandlerThread的最主要的应用场景就是用在IntentService中。</li>
</ul>
<h3 id="11-2-3-IntentService"><a href="#11-2-3-IntentService" class="headerlink" title="11.2.3 IntentService"></a>11.2.3 IntentService</h3><ul>
<li><code>IntentService</code>是一个继承自Service的抽象类，要使用它就要创建它的子类。IntentService适合执行一些<strong>高优先级</strong>的后台任务，这样不容易被系统杀死。IntentService的<code>onCreate</code>方法中会创建HandlerThread，并使用HandlerThread的Looper来构造一个Handler对象ServiceHandler，这样通过ServiceHandler对象发送的消息最终都会在HandlerThread中执行。IntentService会将Intent封装到Message中，通过ServiceHandler发送出去，在ServiceHandler的<code>handleMessage</code>方法中会调用IntentService的抽象方法<code>onHandleIntent</code>，所以IntentService的子类都要是实现这个方法。</li>
</ul>
<h2 id="11-3-Android中的线程池"><a href="#11-3-Android中的线程池" class="headerlink" title="11.3 Android中的线程池"></a>11.3 Android中的线程池</h2><h3 id="11-3-1-使用线程池的好处"><a href="#11-3-1-使用线程池的好处" class="headerlink" title="11.3.1 使用线程池的好处"></a>11.3.1 使用线程池的好处</h3><ol>
<li>重用线程，避免线程的创建和销毁带来的性能开销；</li>
<li>能有效控制线程池的最大并发数，避免大量线程之间互相抢夺系统资源而导致的阻塞现象。</li>
<li>能有效对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ol>
<h3 id="11-3-2-ThreadPoolExecutor"><a href="#11-3-2-ThreadPoolExecutor" class="headerlink" title="11.3.2 ThreadPoolExecutor"></a>11.3.2 ThreadPoolExecutor</h3><ol>
<li><strong>corePoolSize</strong>：核心线程数，默认情况下，核心线程会在线程池中一直存活</li>
<li><strong>maximumPoolSize</strong>：最大线程数，当活动线程数达到这个数值后，后续任务将会被阻塞</li>
<li><strong>keepAliveTime</strong>：非核心线程闲置时的超时时长，超过这个时长，闲置的非核心线程就会被回收</li>
<li><strong>unit</strong>：用于指定keepAliveTime参数的时间单位，有<code>TimeUnit.MILLISECONDS</code>、<code>TimeUnit.SECONDS</code>、<code>TimeUnit.MINUTES</code>等；</li>
<li><strong>workQueue</strong>：任务队列，通过线程池的excute方法提交的Runable对象存储在这个参数中</li>
<li><strong>threadFactory</strong>：线程工厂，为线程池提供创建新线程的功能，它是一个接口，它只有一个方法<code>Thread newThread(Runnable r);</code></li>
<li><strong>RejectedExecutionHandler</strong>：当线程池无法执行新任务时，可能是由于任务队列已满或者是无法成功执行任务，这个时候就会调用这个Handler的<code>rejectedExecution</code>方法来通知调用者，默认情况下，<code>rejectedExecution</code>会直接抛出一个<code>rejectedExecutionException</code></li>
</ol>
<h3 id="11-3-3-线程池的分类"><a href="#11-3-3-线程池的分类" class="headerlink" title="11.3.3 线程池的分类"></a>11.3.3 线程池的分类</h3><ol>
<li><p><strong>FixedThreadPool</strong>：线程数量固定的线程池，它只有核心线程；</p>
</li>
<li><p><strong>CachedThreadPool</strong>：线程数量不固定的线程池，它只有非核心线程；</p>
</li>
<li><p><strong>ScheduledThreadPool</strong>：核心线程数量固定，非核心线程数量没有限制的线程池，并且只要非核心线程一闲置，马上回收，主要用于执行定时任务和具有固定周期的任务；</p>
</li>
<li><p><strong>SingleThreadPool</strong>：只有一个核心线程的线程池，确保了所有的任务都在同一个线程中按顺序执行。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;11-1-主线程和子线程&quot;&gt;&lt;a href=&quot;#11-1-主线程和子线程&quot; class=&quot;headerlink&quot; title=&quot;11.1 主线程和子线程&quot;&gt;&lt;/a&gt;11.1 主线程和子线程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在Java中默认情况下一个进程只有一个线程
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Android的消息机制</title>
    <link href="https://startwithwzk.github.io/2017/07/25/%E7%AC%AC%E5%8D%81%E7%AB%A0%20Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://startwithwzk.github.io/2017/07/25/第十章 Android的消息机制/</id>
    <published>2017-07-25T11:16:11.000Z</published>
    <updated>2017-07-25T11:26:01.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="10-1-Android消息机制概述"><a href="#10-1-Android消息机制概述" class="headerlink" title="10.1 Android消息机制概述"></a>10.1 Android消息机制概述</h2><ol>
<li>Android的消息机制主要是指Handler的运行机制，其底层需要MessageQueue和Looper的支持。</li>
<li>Android规定UI操作只能在主线程中进行，<code>ViewRootImpl</code>的<code>checkThread</code>方法会验证当前线程是否可以进行UI操作。<blockquote>
<p><strong>为什么系统不允许在子线程中访问UI的？</strong></p>
<ol>
<li>因为UI组件不是线程安全的，如果在多线程中并发访问可能会导致UI组件处于不可预期的状态。</li>
</ol>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>为什么系统不对UI控件的访问加上锁机制？</strong></p>
<ol>
<li>首先加上锁机制会让UI访问的逻辑变得复杂</li>
<li>其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行</li>
</ol>
</blockquote>
<ol>
<li>Handler创建时会采用当前线程的Looper来创建内部的消息循环系统，如果当前线程中不存在Looper的话就会报错。Handler可以用<code>post</code>方法将一个Runnable投递到消息队列中，也可以用<code>send</code>方法发送一个消息投递到相抵队列中，其实<code>post</code>最终还是调用了<code>send</code>方法。</li>
</ol>
<h2 id="10-2-Android的消息机制分析"><a href="#10-2-Android的消息机制分析" class="headerlink" title="10.2 Android的消息机制分析"></a>10.2 Android的消息机制分析</h2><h3 id="10-2-1-ThreadLocal-的工作原理"><a href="#10-2-1-ThreadLocal-的工作原理" class="headerlink" title="10.2.1 ThreadLocal 的工作原理"></a>10.2.1 ThreadLocal 的工作原理</h3><ol>
<li><p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。一般来说，当某些数据是以<strong>线程为作用域并且不同线程具有不同的数据副本</strong>的时候，可以考虑使用ThreadLocal。对于Handler来说，它需要获取当前线程的Looper，而Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以实现Looper在线程中的存取了。</p>
</li>
<li><p>ThreadLocal的原理：不同线程访问同一个ThreadLocal的get方法时，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同线程中维护一套数据的副本并且彼此互不干扰。</p>
</li>
<li><p><code>Values</code>是Thread类内部专门用来存储线程的ThreadLocal数据的成员变量，它内部有一个数组<code>private Object[] table</code>，ThreadLocal的值就存在这个table数组中。如果values的值为null，那么就需要对其进行初始化然后再将ThreadLocal的值进行存储。==ThreadLocal数据的存储规则：ThreadLocal的值在table数组中的存储位置总是ThreadLocal的索引+1的位置。==</p>
</li>
</ol>
<h3 id="10-2-2-MessageQueue的工作原理"><a href="#10-2-2-MessageQueue的工作原理" class="headerlink" title="10.2.2 MessageQueue的工作原理"></a>10.2.2 MessageQueue的工作原理</h3><ol>
<li><p>MessageQueue其实是通过单链表来维护消息列表的，它包含两个主要操作enqueueMessage和next，前者是插入消息，后者是取出一条消息并移除。</p>
</li>
<li><p>next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新消息到来时，next方法会返回这条消息并将它从链表中移除。</p>
</li>
</ol>
<h3 id="10-2-3-Looper的工作原理"><a href="#10-2-3-Looper的工作原理" class="headerlink" title="10.2.3 Looper的工作原理"></a>10.2.3 Looper的工作原理</h3><ol>
<li><p>Looper的<code>prepareMainLooper</code>方法主要是给主线程也就是ActivityThread创建Looper使用的，本质也是调用了prepare方法。</p>
</li>
<li><p>Looper的<code>quit</code>和<code>quitSafely</code>方法的区别是：前者会直接退出Looper，后者只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper退出之后，通过Handler发送的消息就会失败，这个时候Handler的send方法会返回false。==在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用<code>quit</code>方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。==</p>
</li>
<li><p>Looper的<code>loop</code>方法会调用MessageQueue的<code>next</code>方法来获取新消息，而<code>next</code>是一个阻塞操作，当没有消息时，<code>next</code>方法会一直阻塞着在那里，这也导致了loop方法一直阻塞在那里。如果MessageQueue的<code>next</code>方法返回了新消息，Looper就会处理这条消息：<code>msg.target.dispatchMessage(msg)</code>，其中的msg.target就是发送这条消息的Handler对象。</p>
</li>
</ol>
<h3 id="10-2-4-Handler的工作原理"><a href="#10-2-4-Handler的工作原理" class="headerlink" title="10.2.4 Handler的工作原理"></a>10.2.4 Handler的工作原理</h3><ol>
<li><p>Handler就是处理消息的发送和接收之后的处理</p>
</li>
<li><p>Handler处理消息的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);<span class="comment">//当message是runnable的情况，也就是Handler的post方法传递的参数，这种情况下直接执行runnable的run方法</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;<span class="comment">//如果创建Handler的时候是给Handler设置了Callback接口的实现，那么此时调用该实现的handleMessage方法</span></div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);<span class="comment">//如果是派生Handler的子类，就要重写handleMessage方法，那么此时就是调用子类实现的handleMessage方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        message.callback.run();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Subclasses must implement this to receive messages.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Handler还有一个特殊的构造方法，它可以通过特定的Looper来创建Handler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span></span>&#123;</div><div class="line">  <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Android的主线程就是<code>ActivityThread</code>，主线程的入口方法就是<code>main</code>，其中调用了<code>Looper.prepareMainLooper()</code>来创建主线程的Looper以及MessageQueue，并通过<code>Looper.loop()</code>方法来开启主线程的消息循环。主线程内有一个Handler，即<code>ActivityThread.H</code>，它定义了一组消息类型，主要包含了四大组件的启动和停止等过程，例如<code>LAUNCH_ACTIVITY</code>等。</p>
</li>
<li><p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方法完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;10-1-Android消息机制概述&quot;&gt;&lt;a href=&quot;#10-1-Android消息机制概述&quot; class=&quot;headerlink&quot; title=&quot;10.1 Android消息机制概述&quot;&gt;&lt;/a&gt;10.1 Android消息机制概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>四大组件的工作过程</title>
    <link href="https://startwithwzk.github.io/2017/07/25/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>https://startwithwzk.github.io/2017/07/25/第九章 四大组件的工作过程/</id>
    <published>2017-07-25T11:15:54.000Z</published>
    <updated>2017-07-25T11:26:23.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="9-1-四大组件的运行状态"><a href="#9-1-四大组件的运行状态" class="headerlink" title="9.1 四大组件的运行状态"></a>9.1 四大组件的运行状态</h2><ul>
<li><p>四大组件中只有BroadcastReceiver既可以在AndroidManifest文件中注册，也可以在代码中注册，其他三个组件都必须在AndroidManifest文件中注册；ContentProvider的调用不需要借助Intent，其他三个组件都需要借助Intent。</p>
</li>
<li><p>Activity是一种展示型组件，向用户直接地展示一个界面。Activity组件是可以停止的，在实际开发中可以通过Activity的finish方法来结束一个Activity组件的运行。</p>
</li>
<li><p>Service是一种计算型组件，用于在后台执行一系列计算任务。Service组件有两种状态：启动状态和绑定状态。当service处于绑定状态时，外界可以很方便的和service进行通信，而在启动状态中是不可与外界通信的。尽管Service组件是用于执行后台计算的，但是它本身是运行在主线程中的，因此不能进行太耗时的运算。Service组件也是可以停止的，需要灵活采用stopService和UNBindService这两个方法才能完全停止一个Service组件。</p>
</li>
<li><p>BroadcastReceiver是一种消息型组件，用于不同的组件乃至不同的应用之间传递消息。广播的注册有两种方式，静态注册和动态注册。</p>
</li>
<li><p>ContentProvider是一种数据共享型组件，用于向其他组件乃至其他应用共享数据。它的内部需要实现增删查改这四种操作，在它内部维持着一份数据集合，这个数据集合既可以是数据库也可以采用任何其他类型来实现。另外ContentProvider内部的insert、delete、update和query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的。</p>
</li>
</ul>
<h2 id="9-2-Activity的工作过程"><a href="#9-2-Activity的工作过程" class="headerlink" title="9.2 Activity的工作过程"></a>9.2 Activity的工作过程</h2><ol>
<li><p>Activity启动的大致流程：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://p1.bpimg.com/567571/f0bacb7b8feba76f.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
</li>
<li><p><code>ApplicationThread</code>是<code>ActivityThread</code>的一个内部类，它继承自<code>ApplicationThreadNative</code>，而<code>ApplicationThreadNative</code>继承自<code>Binder</code>并实现了<code>IApplicationThread</code>接口，<code>ApplicationThreadNative</code>的作用其实就和系统为AIDL文件生成的类是一样的。</p>
</li>
<li><p><code>ActivityManagerService</code>(AMS)继承自<code>ActivityManagerNative</code>，而<code>ActivityManagerNative</code>继承自<code>Binder</code>并实现了<code>IActivityManager</code>这个Binder接口，因此AMS也是一个Binder。</p>
</li>
<li><p>一个应用只有一个Application对象，它的创建也是通过<code>Instrumentation</code>来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。</p>
</li>
<li><p><code>ContextImpl</code>是Context的具体实现，ContextImpl是通过Activity的<code>attach</code>方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当window接收到外部输入事件后就可以将事件传递给Activity。[这里可能有误，应该是Activity将事件传递给window]</p>
</li>
</ol>
<h2 id="9-3-Service的工作过程"><a href="#9-3-Service的工作过程" class="headerlink" title="9.3 Service的工作过程"></a>9.3 Service的工作过程</h2><p>Service有两种状态：启动状态和绑定状态，两种状态是可以共存的。</p>
<ul>
<li><p><strong>启动过程</strong>：<br><img src="http://p1.bqimg.com/567571/36be20d6ed41012a.jpg" alt="启动"></p>
</li>
<li><p><strong>绑定过程</strong>：<br><img src="http://i1.piimg.com/567571/4e786ae6d8e19a92.jpg" alt="绑定"></p>
</li>
</ul>
<h2 id="BroadcastReceiver的工作过程"><a href="#BroadcastReceiver的工作过程" class="headerlink" title="BroadcastReceiver的工作过程"></a>BroadcastReceiver的工作过程</h2><ol>
<li>BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。<ol>
<li>注册过程：静态注册的时候是由<code>PackageManagerService</code>来完成整个注册过程，下面是动态注册的过程：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://p1.bqimg.com/567571/1c49f334af8a8948.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></li>
</ol>
</li>
</ol>
<h2 id="ContentProvider的工作过程"><a href="#ContentProvider的工作过程" class="headerlink" title="ContentProvider的工作过程"></a>ContentProvider的工作过程</h2><ol>
<li><p>当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先于Application的onCreate执行。</p>
</li>
<li><p>ContentProvider的启动过程：</p>
<ol>
<li><p>当一个应用启动时，入口方法是<code>ActivityThread</code>的<code>main</code>方法，其中创建<code>ActivityThread</code>的实例并创建主线程的消息队列</p>
</li>
<li><p><code>ActivityThread</code>的<code>attach</code>方法中会远程调用<code>ActivityManagerService</code>的<code>attachApplication</code>，并将<code>ApplicationThread</code>提供给AMS，<code>ApplicationThread</code>主要用于<code>ActivityThread</code>和AMS之间的通信</p>
</li>
<li><p><code>ActivityManagerService</code>的<code>attachApplication</code>会调用<code>ApplicationThread</code>的<code>bindApplication</code>方法，这个方法会通过H切换到<code>ActivityThread</code>中去执行，即调用<code>handleBindApplication</code>方法</p>
</li>
<li><p><code>handleBindApplication</code>方法会创建<code>Application</code>对象并加载<code>ContentProvider</code>，注意是先加载<code>ContentProvider</code>，然后调用<code>Application</code>的<code>onCreate</code>方法。</p>
</li>
</ol>
</li>
<li><p>ContentProvider的<code>android:multiprocess</code>属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。</p>
</li>
<li><p>当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://box.kancloud.cn/2015-12-10_56692ec8cd215.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;9-1-四大组件的运行状态&quot;&gt;&lt;a href=&quot;#9-1-四大组件的运行状态&quot; class=&quot;headerlink&quot; title=&quot;9.1 四大组件的运行状态&quot;&gt;&lt;/a&gt;9.1 四大组件的运行状态&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;四大组件中只有BroadcastR
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>理解Window和WindowManager</title>
    <link href="https://startwithwzk.github.io/2017/07/25/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager/"/>
    <id>https://startwithwzk.github.io/2017/07/25/第八章 理解Window和WindowManager/</id>
    <published>2017-07-25T11:15:39.000Z</published>
    <updated>2017-07-25T11:26:44.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="8-1-Window和WindowManager"><a href="#8-1-Window和WindowManager" class="headerlink" title="8.1 Window和WindowManager"></a>8.1 Window和WindowManager</h2><p>WindowManager的LayoutParams中的<strong>flags</strong>和<strong>type</strong>这两个参数比较重要，其中关于Flags参数，有几个常用的属性</p>
<ul>
<li><p><strong>FLAG_NOT_FOCUSABLE</strong>：表示Window不要获得焦点，也不需要接收各种输入时间，此标记会同时启用<strong>FLAG_NOT_TOUCH_MODAL</strong>，最终事件会直接传递给下层的具有焦点的Window</p>
</li>
<li><p><strong>FLAG_NOT_TOUCH_MODAL</strong>：系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理。一般来说都需要开启此标记，否则其他window将无法收到单击事件</p>
</li>
<li><p><strong>FLAG_SHOW_WHEN_LOCKED</strong>：开启此模式可以让Window显示在锁屏的界面上</p>
</li>
</ul>
<p>关于Type参数</p>
<ul>
<li>应用Window层级范围1~99</li>
<li>子Window层级范围1000~1999</li>
<li>系统Window层级范围是2000~2999（可以选用TYPE_SYSTEM_OVERLAY或者TYPE_SYSTEM_ERROR，如果选用后者，需要声明权限）</li>
</ul>
<p>WindowManager继承自ViewManager，常用的只有三个方法：addView、updateView和removeView。</p>
<h2 id="8-2-Window的内部机制"><a href="#8-2-Window的内部机制" class="headerlink" title="8.2 Window的内部机制"></a>8.2 Window的内部机制</h2><ol>
<li><p>Window是一个抽象的概念，不是实际存在的，它也是以View的形式存在。在实际使用中无法直接访问Window，只能通过WindowManager才能访问Window。每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。</p>
</li>
<li><p>Window的添加、删除和更新过程都是IPC过程，以Window的添加为例，WindowManager的实现类WindowManagerImpl对于addView、updateView和removeView方法都是委托给WindowManagerGlobal类（该类以工厂方式向外提供自己的实例），该类保存了很多数据列表，例如所有window对应的view集合mViews、所有window对应的ViewRootImpl的集合mRoots等，之后添加操作交给了ViewRootImpl来处理，接着会通过WindowSession来完成Window的添加过程，这个过程是一个IPC调用，因为最终是通过WindowManagerService来完成window的添加的。</p>
</li>
<li><p>dispatchDetachedFromWindow方法作用</p>
<ol>
<li>垃圾回收，比如清除数据和消息、移除回调</li>
<li>通过Session的remove方法删除Window，这是一个IPC调用</li>
<li>调用View的dispatchDetachedFromWindow方法</li>
<li>调用WindowManagerGlobal的doRemove方法刷新数据。</li>
</ol>
</li>
</ol>
<h2 id="8-3-Window的创建过程"><a href="#8-3-Window的创建过程" class="headerlink" title="8.3 Window的创建过程"></a>8.3 Window的创建过程</h2><h3 id="8-3-1-Activity的Window创建过程"><a href="#8-3-1-Activity的Window创建过程" class="headerlink" title="8.3.1 Activity的Window创建过程"></a>8.3.1 Activity的Window创建过程</h3><ol>
<li><p>Activity的启动过程很复杂，最终会由<code>ActivityThread</code>中的<code>performLaunchActivity</code>来完成整个启动过程，在这个方法内部会通过<strong>类加载器</strong>创建Activity的实例对象，并调用它的attach方法为其关联运行过程中所依赖的一系列上下文环境变量；</p>
</li>
<li><p>Activity实现了Window的Callback接口，当window接收到外界的状态变化时就会回调Activity的方法，例如<code>onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent</code>等；</p>
</li>
<li><p>Activity的Window是由PolicyManager的<code>makeNewWindow</code>方法来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的；</p>
</li>
<li><p>Activity的顶级View是DecorView，它本质上是一个FrameLayout。如果没有DecorView，那么PhoneWindow会先创建一个DecorView，然后加载具体的布局文件并将view添加到DecorView的mContentParent中，最后就是回调Activity的onContentChanged通知Activity视图已经发生了变化；</p>
</li>
<li><p>需要注意的是，此时DecorView还没有被WindowManager正式添加到Window中，还有一个步骤是让WindowManager能够识别DecorView，在ActivityThread调用<code>handleResumeActivity</code>方法时，首先会调用Activity的onResume方法，然后会调用makeVisible方法，这个方法中DecorView真正地完成了添加和显示过程。</p>
</li>
</ol>
<h3 id="8-3-2-Dialog的Window创建过程"><a href="#8-3-2-Dialog的Window创建过程" class="headerlink" title="8.3.2 Dialog的Window创建过程"></a>8.3.2 Dialog的Window创建过程</h3><ol>
<li>过程与Activity的Window创建过程类似，普通的Dialog的有一个特别之处，即它必须采用Activity的Context，如果采用Application的Context会报错。原因是Application没有应用token，应用token一般是Activity拥有的。[service貌似也有token?]</li>
</ol>
<h3 id="8-3-3-Toast的Window创建过程"><a href="#8-3-3-Toast的Window创建过程" class="headerlink" title="8.3.3 Toast的Window创建过程"></a>8.3.3 Toast的Window创建过程</h3><ol>
<li>Toast属于系统Window，它内部的视图由两种方式指定：一种是系统默认的样式；另一种是通过setView方法来指定一个自定义的View。</li>
</ol>
<p>2.Toast具有定时取消功能，所以系统采用了Handler。Toast的显示和隐藏是IPC过程，都需要NotificationManagerService来实现。在Toast和NMS进行IPC过程时，NMS会跨进程回调Toast中的TN类中的方法，TN类是一个Binder类，运行在Binder线程池中，所以需要通过Handler将其切换到当前发送Toast请求所在的线程，所以Toast无法在没有Looper的线程中弹出。</p>
<p>3.对于非系统应用来说，mToastQueue最多能同时存在50个ToastRecord，这样做是为了防止DOS(Denial of Service，拒绝服务)。因为如果某个应用弹出太多的Toast会导致其他应用没有机会弹出Toast。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;8-1-Window和WindowManager&quot;&gt;&lt;a href=&quot;#8-1-Window和WindowManager&quot; class=&quot;headerlink&quot; title=&quot;8.1 Window和WindowManager&quot;&gt;&lt;/a&gt;8.1 Window和Win
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Android动画深入分析</title>
    <link href="https://startwithwzk.github.io/2017/07/25/%E7%AC%AC%E4%B8%83%E7%AB%A0%20Android%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <id>https://startwithwzk.github.io/2017/07/25/第七章 Android动画深入分析/</id>
    <published>2017-07-25T11:15:30.000Z</published>
    <updated>2017-07-25T11:27:03.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-1-View动画"><a href="#7-1-View动画" class="headerlink" title="7.1 View动画"></a>7.1 View动画</h2><h3 id="7-1-1-View动画的种类"><a href="#7-1-1-View动画的种类" class="headerlink" title="7.1.1 View动画的种类"></a>7.1.1 View动画的种类</h3><p>View动画四种变换效果对应着Animation的四个子类：TranslateAnimation、ScaleAnimation、RotateAnimation和AlphaAnimation，也可以用XML来定义，建议使用XML，因为可读性更好。</p>
<ul>
<li><strong><set></set></strong>：对应于AnimationSet类，它可以包含若干个动画。并且也可以被嵌套在其他动画中。<ul>
<li><strong>android: interpolator</strong>：表示动画的插值器，插值器影响动画的速度。不指定，默认为<code>@android:anim/accelerate_decelerate_interpolator</code>，即加速减速插值器。</li>
<li><strong>android: shareInterpolator</strong>：表示集合中的动画是否和集合共享同一个插值器。</li>
</ul>
</li>
</ul>
<p>通过Animation的setAnimationListener方法可以给View动画添加过程监听。</p>
<h3 id="7-1-2-自定义View动画"><a href="#7-1-2-自定义View动画" class="headerlink" title="7.1.2 自定义View动画"></a>7.1.2 自定义View动画</h3><p>继承Animation这个抽象类，然后重写它的initialize和applyTransFormation方法，在initialize方法中做一些初始化工作，在applyTransformation中进行相应的矩阵变换，很多时候需要采用Camera来简化矩阵变换的过程。</p>
<h3 id="7-1-3-帧动画"><a href="#7-1-3-帧动画" class="headerlink" title="7.1.3 帧动画"></a>7.1.3 帧动画</h3><p>帧动画是顺序播放一组预先定义好的图片，类型电影播放，系统提供了另外一个类AnimationDrawable来使用帧动画，首先需要用XML来定义一个AnimationDrawable，标签为<animation-list>。比较容易引发OOM，所以使用的时候尽量避免使用过多尺寸较大的图片。</animation-list></p>
<h2 id="7-2-View动画的特殊使用场景"><a href="#7-2-View动画的特殊使用场景" class="headerlink" title="7.2 View动画的特殊使用场景"></a>7.2 View动画的特殊使用场景</h2><h3 id="7-2-1-LayoutAnimation"><a href="#7-2-1-LayoutAnimation" class="headerlink" title="7.2.1 LayoutAnimation"></a>7.2.1 LayoutAnimation</h3><p>LayoutAnimation作用于ViewGroup，为ViewGroup指定一个动画，这样当它的子元素出场都具有这种动画效果。它的使用步骤为</p>
<ol>
<li>定义LayoutAnimation。<ul>
<li><strong>android: delay</strong>：表示子元素开始动画的时间延迟，比如子元素入场动画的时间周期为300ms，那么0.5表示每个子元素都需要延迟150ms才能播放入场动画。</li>
<li><strong>android: animationOrder</strong>：表示子元素动画的顺序，有三种选项：normal、reverse和random，其中normal表示顺序显示；reverse表示逆向显示；random则是随机播放入场动画。</li>
<li><strong>android: animation</strong>：为子元素指定具体入场动画。</li>
</ul>
</li>
<li>为子元素设置具体的入场动画。</li>
<li>为ViewGroup指定android :layoutAnimation属性。</li>
</ol>
<p>Ps.除了在XML中指定LayoutAnimation外，还可以通过LayoutAnimationController来实现。</p>
<h3 id="7-2-2-Activity的切换效果"><a href="#7-2-2-Activity的切换效果" class="headerlink" title="7.2.2 Activity的切换效果"></a>7.2.2 Activity的切换效果</h3><p>Activity有默认的切换效果，但是这个效果是可以自定义的，主要用到<code>overridePendingTransition(int enterAnim, int exitAnim)</code>，这个方法必须在startActivity(intent)或者finish()之后调用才能生效。</p>
<p>Ps.Fragment也可以添加切换动画</p>
<h2 id="7-3-属性动画"><a href="#7-3-属性动画" class="headerlink" title="7.3 属性动画"></a>7.3 属性动画</h2><h3 id="7-3-1-使用属性动画"><a href="#7-3-1-使用属性动画" class="headerlink" title="7.3.1 使用属性动画"></a>7.3.1 使用属性动画</h3><ul>
<li>属性动画默认时间间隔300ms，默认帧率10ms/帧</li>
<li>属性动画从API11才有，可以采用开源动画库nineoldandroid来兼容以前的版本。</li>
<li>比较常用的几个动画类是：ValueAnimator、ObjectAnimator和AnimatorSet。其中ObjectAnimator继承自ValueAnimator，AnimatorSet是动画集合。</li>
</ul>
<h3 id="7-3-2-插值器和估值器"><a href="#7-3-2-插值器和估值器" class="headerlink" title="7.3.2 插值器和估值器"></a>7.3.2 插值器和估值器</h3><p>TimeInterpolator中文译为时间插值器，它的作用是根据时间流逝的百分比来计算出当前属性改变的百分比；TypeEvaluate中文译为类型估值算法，也叫估值器，它的作用是根据当前属性改变的百分比来计算改变后的属性值，系统内置的有IntEvaluator、FloatEvaluator和ArgbEvaluator。</p>
<p>属性动画中的插值器和估值器是实现非匀速动画的重要手段。</p>
<h3 id="7-3-3-属性动画的监听器"><a href="#7-3-3-属性动画的监听器" class="headerlink" title="7.3.3 属性动画的监听器"></a>7.3.3 属性动画的监听器</h3><p>属性动画提供了监听器用于监听动画的播放过程，主要有两个接口，分别为AnimatorUpdateListener和AnimatorListener。</p>
<h3 id="7-3-4-对任意属性做动画"><a href="#7-3-4-对任意属性做动画" class="headerlink" title="7.3.4 对任意属性做动画"></a>7.3.4 对任意属性做动画</h3><p>对object的属性xxx做动画，如果想要动画生效，要同时满足两个条件：</p>
<ol>
<li>object必须要提供setXXX方法，如果动画的时候没有传递初始值，那么还要提供getXXX方法，因为系统要去取XXX属性的初始值。（如果这条不满足，程序直接crash）</li>
<li>object的setXXX对属性XXX所做的改变必须能够通过某种方法反映出来，比如会带来UI的改变。（如果这条不满足，动画无效果但不会crash）</li>
</ol>
<p>针对上面条件二的解决办法是</p>
<ul>
<li>给你的对象加上get和set方法，如果你有权限的话</li>
<li>用一个类来包装原始对象，间接为其提供get和set方法</li>
<li>采用ValueAnimator，监听动画过程，自己实现属性的改变</li>
</ul>
<h2 id="7-4-使用动画的注意事项"><a href="#7-4-使用动画的注意事项" class="headerlink" title="7.4 使用动画的注意事项"></a>7.4 使用动画的注意事项</h2><p>通过动画可以实现一些比较绚丽的的效果，但是使用过程中，也需要注意一些事情，主要分为下面几类。</p>
<ol>
<li>OOM问题</li>
<li>内存泄漏（在属性动画中，有一类无线循环的动画，这类动画需要在Activity退出时及时停止）</li>
<li>兼容性问题</li>
<li>View动画问题</li>
<li>不要使用px</li>
<li>硬件加速（使用动画过程中，建议开启硬件加速，这样会提高动画的流畅性）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;7-1-View动画&quot;&gt;&lt;a href=&quot;#7-1-View动画&quot; class=&quot;headerlink&quot; title=&quot;7.1 View动画&quot;&gt;&lt;/a&gt;7.1 View动画&lt;/h2&gt;&lt;h3 id=&quot;7-1-1-View动画的种类&quot;&gt;&lt;a href=&quot;#7-1-1-
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Android的Drawable</title>
    <link href="https://startwithwzk.github.io/2017/07/25/Android%E7%9A%84Drawable/"/>
    <id>https://startwithwzk.github.io/2017/07/25/Android的Drawable/</id>
    <published>2017-07-25T11:15:17.000Z</published>
    <updated>2017-07-25T11:27:18.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-Drawable"><a href="#6-1-Drawable" class="headerlink" title="6.1 Drawable"></a>6.1 Drawable</h2><ul>
<li>Drawable是一个抽象类，每个具体的Drawable都是它的子类，例如ShapeDrawable、BitmapDrawable等。</li>
<li>Drawable的内部宽/高可以通过getIntrinsicWidth和getIntrinsicHeight这两个方法获得。<strong>但并不是所有Drawable都有内部宽高的。</strong></li>
<li>Drawable是没有大小概念的。</li>
</ul>
<h2 id="6-2-Drawable的分类"><a href="#6-2-Drawable的分类" class="headerlink" title="6.2 Drawable的分类"></a>6.2 Drawable的分类</h2><h3 id="6-2-1-BitmapDrawable"><a href="#6-2-1-BitmapDrawable" class="headerlink" title="6.2.1 BitmapDrawable"></a>6.2.1 BitmapDrawable</h3><ul>
<li><strong>android: antialias</strong>：是否开启图片抗锯齿功能。会微小地影响图片清晰度，但是建议开启。</li>
<li><strong>android: dither</strong>：是否开启抖动效果。开启可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果。建议开启。</li>
<li><strong>android: filter</strong>：是否开启过滤效果。当图片尺寸被拉伸或者压缩时，开启此效果可以保持较好的显示效果。</li>
<li><strong>android: tileMode</strong>：这个选项有几个值：[“disabled” | “clamp” | “repeat” | “mirror”]，其中disable是默认值，表示关闭平铺模式。<strong>当开启平铺模式的时候，gravity属性会被忽略</strong>。<ul>
<li>repart表示的是简单的水平和竖直方向上的平铺效果。</li>
<li>mirror：表示的是水平和竖直方向上的镜面投影效果。</li>
<li>clamp：表示的是，图片四周的像素会扩散到周围区域。</li>
</ul>
</li>
</ul>
<h3 id="6-2-2-ShapeDrawable"><a href="#6-2-2-ShapeDrawable" class="headerlink" title="6.2.2 ShapeDrawable"></a>6.2.2 ShapeDrawable</h3><ul>
<li><strong>android: shape</strong>：表示图片的形状。有个四个选项：rectangle（矩形）、oval（椭圆）、line（横线）和ring（圆环）。此外针对ring还有五个特殊属性，使用的时候可以自行查询。</li>
<li><strong><corners></corners></strong>：表示四个角的角度。它只适用于rectangle。</li>
<li><strong><gradient></gradient></strong>：于<solid>标签互相排斥，其中solid表示纯色填充，而gradient表示渐变效果。</solid></li>
<li><strong><solid></solid></strong>：表示纯色填充。</li>
<li><strong><stoke></stoke></strong>：Shape的描边。</li>
<li><strong><padding></padding></strong>：表示包含shape的空白。</li>
<li><strong><size></size></strong>：表示的shape的固有大小。对于shape来说，默认情况下没有固定宽/高，这个时候getIntrinsicWidth/Height会返回-1，但是如果通过<size>标签设定，那么这个时候shape就有了。</size></li>
</ul>
<h3 id="6-2-3-LayerDrawable"><a href="#6-2-3-LayerDrawable" class="headerlink" title="6.2.3 LayerDrawable"></a>6.2.3 LayerDrawable</h3><p>LayerDrawable对应的XML标签是<layer-list>，它表示一种层次化的Drawable集合。下面的item会覆盖上面的item。</layer-list></p>
<h3 id="6-2-4-StateListDrawable"><a href="#6-2-4-StateListDrawable" class="headerlink" title="6.2.4 StateListDrawable"></a>6.2.4 StateListDrawable</h3><p>StateListDrawable对应于<selector>标签，它表示Drawable的集合，每个Drawable都对应于View的一种状态。系统会从上到下的顺序查到符合状态的Drawable。</selector></p>
<ul>
<li><strong>android: constantSize</strong>：固有大小是否随着其状态的改变而改变（不同的Drawable具有不同的固有大小）。默认false并且此时StateList的固有大小是内部所有Drawable的固有大小的最大值。</li>
<li><strong>android: dither</strong>：是否开启抖动。默认true。</li>
<li><strong>android: variablePadding</strong>：padding是否随着其状态的改变而改变（不同的Drawable具有不同的padding）。默认false并且此时StateList的padding是内部所有Drawable的padding的最大值。</li>
</ul>
<h3 id="6-2-5-LeverListDrawable"><a href="#6-2-5-LeverListDrawable" class="headerlink" title="6.2.5 LeverListDrawable"></a>6.2.5 LeverListDrawable</h3><p>LeverListDrawable对应于<level-list>标签，它同样表示一个Drawable集合，集合中每个Drawable都有一个等级或者说等级范围。根据不同的等级，LevelListDrawable会切换为对应的Drawable。可以通过setImageLevel方法来切换Drawable。等级是有范围的，即0~10000。</level-list></p>
<h3 id="6-2-6-TransitionDrawable"><a href="#6-2-6-TransitionDrawable" class="headerlink" title="6.2.6 TransitionDrawable"></a>6.2.6 TransitionDrawable</h3><p>对应于<transition>标签，它用于实现两个Drawable之间的淡入淡出。最后，通过startTransition和reverseTransition方法来实现淡入淡出以及它的逆过程。</transition></p>
<h3 id="6-2-7-InsetDrawable"><a href="#6-2-7-InsetDrawable" class="headerlink" title="6.2.7 InsetDrawable"></a>6.2.7 InsetDrawable</h3><p>对应于<inset>标签，他可以将其他Drawable内嵌到自己当中，并可以在四周留出一定间距。当一个view希望自己的背景比自己实际区域小的时候，可以使用这种方法。</inset></p>
<h3 id="6-2-8-ScaleDrawable"><a href="#6-2-8-ScaleDrawable" class="headerlink" title="6.2.8 ScaleDrawable"></a>6.2.8 ScaleDrawable</h3><p>对应于<scale>标签，它可以根据自己的等级将制定的Drawable缩放到一定比例。</scale></p>
<h3 id="6-2-9-ClipDrawable"><a href="#6-2-9-ClipDrawable" class="headerlink" title="6.2.9 ClipDrawable"></a>6.2.9 ClipDrawable</h3><p>对应于<clip>标签，它可以根据自己当前的等级（level）来裁剪另一个Drawable，裁剪方向可以通过android: clipOrientation和android: gravity这两个属性来共同控制。</clip></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;6-1-Drawable&quot;&gt;&lt;a href=&quot;#6-1-Drawable&quot; class=&quot;headerlink&quot; title=&quot;6.1 Drawable&quot;&gt;&lt;/a&gt;6.1 Drawable&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Drawable是一个抽象类，每个具体的Draw
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>理解RemoteView</title>
    <link href="https://startwithwzk.github.io/2017/07/25/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E7%90%86%E8%A7%A3RemoteView/"/>
    <id>https://startwithwzk.github.io/2017/07/25/第五章 理解RemoteView/</id>
    <published>2017-07-25T11:15:00.000Z</published>
    <updated>2017-07-25T11:27:47.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5-1-RemoteViews的应用"><a href="#5-1-RemoteViews的应用" class="headerlink" title="5.1 RemoteViews的应用"></a>5.1 RemoteViews的应用</h2><p>RemoteViews在实际开发中，主要用于通知栏和桌面小部件的开发过程中。它们在更新界面时无法像在Activity里面那样去直接更新View，因为两者都运行在其它进程中，确切来说是系统的SystemServer进程。</p>
<h3 id="5-1-1-RemoteView在通知栏上的应用"><a href="#5-1-1-RemoteView在通知栏上的应用" class="headerlink" title="5.1.1 RemoteView在通知栏上的应用"></a>5.1.1 RemoteView在通知栏上的应用</h3><ul>
<li>只需要提供当前应用的包名和布局文件的资源id即可创建一个RemoteViews对象。</li>
<li>更新其中的View必须通过RemoteView所提供的的一系列set方法来更新View。（例如设置TextView的文本，<code>remoteView.setTextViewText(R.id.msg, &quot;chapter_5&quot;)</code>）</li>
<li>如果要给一个控件添加点击事件，则要使用PendingIntent并通过setOnclickPendingIntent方法来实现。</li>
</ul>
<h3 id="5-1-2-RemoteViews在桌面小部件上的应用"><a href="#5-1-2-RemoteViews在桌面小部件上的应用" class="headerlink" title="5.1.2 RemoteViews在桌面小部件上的应用"></a>5.1.2 RemoteViews在桌面小部件上的应用</h3><p>AppWidgetProvider是Android中提供的用于实现桌面小部件的类，它继承于BroadcastReceiver.其开发步骤可大致分为以下几步：</p>
<ol>
<li><strong>定义小部件界面</strong></li>
<li><p><strong>定义小部件配置信息</strong>：在res/xml/下新建appwidget_provider_info.xml，其中initialLayout就是指小工具所使用的初始化布局，minHeight和minWidth定义小工具的最小尺寸，undataPeriodMills定义小工具自动更新周期，毫秒为单位。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">appwidget-provider</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:initialLayout</span>=<span class="string">"@layout/widget"</span></div><div class="line">    <span class="attr">android:minHeight</span>=<span class="string">"84dp"</span></div><div class="line">    <span class="attr">android:minWidth</span>=<span class="string">"84dp"</span></div><div class="line">    <span class="attr">android:updatePeriodMillis</span>=<span class="string">"86400000"</span> &gt;</div><div class="line"><span class="tag">&lt;/<span class="name">appwidget-provider</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>定义小部件的实现类</p>
</li>
<li>在AndroidManifest.xml中声明小部件 <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">".MyAppWidgetProvider"</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></div><div class="line">        <span class="attr">android:name</span>=<span class="string">"android.appwidget.provider"</span></div><div class="line">        <span class="attr">android:resource</span>=<span class="string">"@xml/appwidget_provider_info"</span> &gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">meta-data</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--这个Action是作为小部件的标识而必须存在--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.appwidget.action.APPWIDGET_UPDATE"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>此外，除了最常用的onUpdate方法，还有其它几个方法。这些方法会自动被onReceive方法在合适的时间调用。</p>
<ul>
<li><strong>onEnable</strong>：当窗口小部件第一次添加到桌面时调用该方法，可添加多次，但只在第一次调用。</li>
<li><strong>onUpdata</strong>：小部件被添加时或者每次小部件更新时都会调用一次该方法。</li>
<li><strong>onDeleted</strong>：每删除一次桌面小部件就调用一次。</li>
<li><strong>onDisabled</strong>：当最后一个该类型的小部件被删除时调用。</li>
<li><strong>onReceive</strong>：这是广播的内置方法，用于分发具体事件给其他方法。</li>
</ul>
<h3 id="5-1-3-PendingIntent概述"><a href="#5-1-3-PendingIntent概述" class="headerlink" title="5.1.3 PendingIntent概述"></a>5.1.3 PendingIntent概述</h3><p>PendingIntent表示一种处于待定、等待、即将发生状态的意图。它支持三种意图：启动Activity、启动Service和发送广播。</p>
<p>PendingIntent的匹配规则为：如果两个内部的Intent相同并且requestCode也相同，那么就是匹配的。（Intent的匹配规则为：两个Intent的ComponentName和intent-filter都相同）</p>
<p>flag参数的含义：</p>
<ul>
<li><strong>FLAG_ONE_SHOT</strong>：当前PendingIntent只能被使用一次，然后它就会被自动cnacel，如果还有后续的PendingIntent，那么它们的send方法就会调用失败。</li>
<li><strong>FALG_NO_CREATE</strong>：当前PendingIntent不会主动创建，如果当前PendingIntent之前不存在，那么getActivity、getService和getBroadcast会直接返回null。</li>
<li><strong>FLAG_CANCEL_CURRENT</strong>：当前描述的PendingIntent如果已经存在，那么它们被会cancel，然后系统会创建一个新的。</li>
<li><strong>FLAG_UPDATE_CURRENT</strong>：当前描述的PendingIntent如果已经存在，那么它们都会被更新，即它们中的Extras会被替换为最新的。</li>
</ul>
<h2 id="5-2-RemoteViews的内部机制"><a href="#5-2-RemoteViews的内部机制" class="headerlink" title="5.2 RemoteViews的内部机制"></a>5.2 RemoteViews的内部机制</h2><p>通知栏和桌面小部件分别由NotificationManager和AppWidgetManager管理，而NotificationManager和APPWidgetManager通过Binder分别和SystemServer进程中的NotificationManagerService和APPWidgetManagerService进行通信。</p>
<p>RemoteViews目前不能支持所有的View类型，它所支持的类型如下：</p>
<ul>
<li><strong>Layout</strong>：FrameLayout、LinearLayout、RelativeLayout、GridLayout</li>
<li><strong>View</strong>：AnalogClock、Button、Chronometer、ImageButton、ImageView、ProgressBar、TextView、ViewFlipper、ListView、GridView、StackView、AdapterViewFlipper、ViewStub</li>
</ul>
<p>RemoteViews中的大部分set方法是通过反射来完成的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;5-1-RemoteViews的应用&quot;&gt;&lt;a href=&quot;#5-1-RemoteViews的应用&quot; class=&quot;headerlink&quot; title=&quot;5.1 RemoteViews的应用&quot;&gt;&lt;/a&gt;5.1 RemoteViews的应用&lt;/h2&gt;&lt;p&gt;Remote
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="View" scheme="https://startwithwzk.github.io/tags/View/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>View的工作原理</title>
    <link href="https://startwithwzk.github.io/2017/07/25/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://startwithwzk.github.io/2017/07/25/第四章 View的工作原理/</id>
    <published>2017-07-25T11:14:45.000Z</published>
    <updated>2017-07-25T11:28:54.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-1-ViewRoot和DecorView"><a href="#4-1-ViewRoot和DecorView" class="headerlink" title="4.1 ViewRoot和DecorView"></a>4.1 ViewRoot和DecorView</h2><ul>
<li><p>ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。</p>
</li>
<li><p>View的绘制流程是从ViewRoot的performTraversals方法开始的，它会依次调用performMeasure、performLayout和performDraw三个方法。</p>
</li>
<li>measure过程决定了View的宽/高，Measure完成以后，可以通过getMeasuredWidth和getMeasuredHeight方法来获取View测量后的宽/高，==几乎所有情况下都等于view最终的宽和高。==</li>
<li>layout过程决定了，View四个顶点的坐标和实际的View的宽和高，完成以后，可以通过getTop、getLeft等方法来拿到View的四个顶点的位置，并可以通过getWidth和getHeight方法拿到View的最终宽和高。</li>
<li>Draw过程则决定了View的显示，只有draw方法完成以后View的内容才能呈现在屏幕上。</li>
<li>DecorView作为顶级View，一般情况下它内部会包含一个竖直方向的LinearLayout，在其中有上下两部分（具体情况和Android版本以及主题有关），上面是标题栏，下面是内容栏。</li>
</ul>
<h2 id="4-2-理解MeasureSpec"><a href="#4-2-理解MeasureSpec" class="headerlink" title="4.2 理解MeasureSpec"></a>4.2 理解MeasureSpec</h2><h3 id="4-2-1-MeasureSpec"><a href="#4-2-1-MeasureSpec" class="headerlink" title="4.2.1 MeasureSpec"></a>4.2.1 MeasureSpec</h3><ol>
<li><p>MeasureSpec代表一个32位的int值，其中高两位代表SpecMode，低30位代表SpecSize，SpecMode是指测量模式，而SpecSize是指在某种测量模式下的规格大小。</p>
</li>
<li><p>MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的内存分配。</p>
</li>
<li><p>SpecMode有三类，每一类都表示特殊的含义：</p>
<ul>
<li><strong>UNSPECIFIED</strong>：父容器不对View有任何限制，要多大给多大，这种情况用于系统内部，表示一种测量状态。</li>
<li><strong>EXACTLY</strong>：父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值（dp）这两种模式。</li>
<li><strong>AT_MOST</strong>：父容器指定了一个可用大小即SpecSize，View的大小不能大于这个值，<strong>具体是什么值要看不同View的实现</strong>。它对应于LayoutParams中的wrap_content。</li>
</ul>
</li>
</ol>
<h3 id="4-2-2-MeasureSpec和LayoutParams的对应关系"><a href="#4-2-2-MeasureSpec和LayoutParams的对应关系" class="headerlink" title="4.2.2 MeasureSpec和LayoutParams的对应关系"></a>4.2.2 MeasureSpec和LayoutParams的对应关系</h3><ul>
<li><p>在View测量的时候，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后再根据这个MeasureSpec来确定View测量后的宽/高。</p>
</li>
<li><p>对于DecorView，其MeasureSpec由窗口的尺寸和其自身的LayoutParams来共同确定；对于普通的View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定。MeasureSpec一旦确定后，onMeasure中就可以确定View的测量宽/高。</p>
</li>
<li><p>子View和父容器的MeasureSpec关系归纳：</p>
<ol>
<li>当子View采用固定宽/高的时候，无论父容器的MeasureSpec是什么，View的MeasureSpec都是精确模式并且其大小遵循LayoutParams中的值。</li>
<li>子View为match_parent时，如果父容器是精确模式，则子View也为精确模式且为父容器的剩余空间大小；如果父容器是wrap_content，则子View也是wrap_content且不会超过父容器的剩余空间。</li>
<li>子View为wrap_content时，无论父View是精确还是最大化，子View的模式总是wrap_content，且不会超过父容器的剩余空间。</li>
</ol>
</li>
</ul>
<h2 id="4-3-View的工作流程"><a href="#4-3-View的工作流程" class="headerlink" title="4.3 View的工作流程"></a>4.3 View的工作流程</h2><h3 id="4-3-1-measure过程"><a href="#4-3-1-measure过程" class="headerlink" title="4.3.1 measure过程"></a>4.3.1 measure过程</h3><ul>
<li>View的measure方法是一个final类型的方法，子类无法重写，而在其中会调用View的onMeasure方法，故只需要重写这个方法就好了。</li>
<li>View的measure过程：直接继承View（特指单独View）的自定义控件需要重写onMeasure方法，并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。（TextView、Imageview等系统控件的onMeasure均做了特殊处理）</li>
<li>在某种情况下，系统可能多次measure才能群定最终的测量宽/高，一个比较好的习惯是在onLayout方法中去获取View的测量宽高或最终宽高。</li>
<li>由于View的measure过程和Activity的生命周期方法不是同步执行的，因此无法保证在Activity的onCreate、onStart、onResume时某个View已经测量完毕了。有四种方法可以在Activity初始化的准确获取View的宽高<ul>
<li>Activity/View#onWindowFocusChanged：View已经初始化完毕了。（注意该方法会在Activity Pause和resume时被多次调用）</li>
<li>view.post(runnable)：通过post将一个runnable投递到消息队列尾部，然后等地Looper调用。</li>
<li>ViewTreeObserver中的onGlobalLayoutListener中。（可能会被调用多次，当View树的状态发生改变或者View树内部的view的可见性发生改变时，都会回调）</li>
<li>view.measure(int widthMeasureSpec, int heightMeasureSpec)：通过手动测量，从而获得宽高，这种情况比较复杂。</li>
</ul>
</li>
</ul>
<h3 id="4-3-2-layout过程"><a href="#4-3-2-layout过程" class="headerlink" title="4.3.2 layout过程"></a>4.3.2 layout过程</h3><ul>
<li>layout中可能会使view的大小大于测量的大小</li>
<li>layout方法大致流程，首先会通过setFrame方法来初始化View的四个顶点的位置，View的四个顶点一旦确定，那么View在父容器中的位置也就确定了；接着会调用onLayout方法，这个方法的用途就是父容器确定子元素的位置。</li>
</ul>
<h3 id="4-3-3-draw过程"><a href="#4-3-3-draw过程" class="headerlink" title="4.3.3 draw过程"></a>4.3.3 draw过程</h3><ul>
<li>draw的过程：绘制背景（background.draw(canvas)），绘制自己（onDraw()），绘制chidren（dispatchDraw），绘制装饰（onDrawScrollBars）</li>
<li>setWillNotDraw方法用于在一个View不需要绘制时的优化（设置为true时）。</li>
</ul>
<h2 id="4-4-自定义View"><a href="#4-4-自定义View" class="headerlink" title="4.4 自定义View"></a>4.4 自定义View</h2><ol>
<li><p><strong>让View支持wrap_content</strong>：直接继承View或者ViewGroup的空间，如果不在onMeasure中对wrap_content做特殊处理，那么match_parent和wrap_content是一样的效果。</p>
</li>
<li><p><strong>让View支持padding</strong>：直接继承View的控件，如果不在onDraw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件，需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响（因为子元素的margin是由父容器控制的），不然将会导致padding和子元素的margin失效。</p>
</li>
<li><p><strong>尽量不要在View中使用Handler</strong>：因为View内部本身就提供了post系列的方法，完全可以替代Handler的作用。</p>
</li>
<li><p><strong>View中如果有线程或者动画，需要及时停止</strong>：View#onDetachedFromWindow这个方法是一个很好的时机。当包含此View的Activity退出或者当前View被remove时，View的onDetachedFromWindow方法会被调用。同时，当View变得不可见时我们也需要停止线程和动画，如果不处理，有可能造成内存泄漏。</p>
</li>
<li><p><strong>View带有滑动嵌套情形时，需要处理好滑动冲突</strong>：这方面的内容，在第三章的时候有提及。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;4-1-ViewRoot和DecorView&quot;&gt;&lt;a href=&quot;#4-1-ViewRoot和DecorView&quot; class=&quot;headerlink&quot; title=&quot;4.1 ViewRoot和DecorView&quot;&gt;&lt;/a&gt;4.1 ViewRoot和DecorVi
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="View" scheme="https://startwithwzk.github.io/tags/View/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>第三章 View的事件体系</title>
    <link href="https://startwithwzk.github.io/2017/07/22/%E7%AC%AC%E4%B8%89%E7%AB%A0%20View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
    <id>https://startwithwzk.github.io/2017/07/22/第三章 View的事件体系/</id>
    <published>2017-07-22T15:27:00.000Z</published>
    <updated>2017-07-22T15:32:48.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-View的基础知识"><a href="#1-View的基础知识" class="headerlink" title="1. View的基础知识"></a>1. View的基础知识</h2><h3 id="1-1-View的位置参数"><a href="#1-1-View的位置参数" class="headerlink" title="1.1 View的位置参数"></a>1.1 View的位置参数</h3><ul>
<li>View的位置由其四个属性来决定，分别是top、left、right和bottom，并且View为它们提供了get/set方法，它们的坐标都是相对于父容器而言，因此是一种相对坐标。在Android中，x轴和y轴的正方向分别为右和下。</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170220111655145?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSU9fRmllbGQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li><p>从Android3.0开始，View增加了几个参数：x、y、translationX和translationY，其中x和y是View左上角的的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。这几个参数也是相对于父容器的坐标，并且translationX和translationY的默认值为0。它们的换算关系如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = left + translationX</div></pre></td></tr></table></figure>
</li>
<li><p>View在平移过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的x、y、translationX和translationY这四个参数。</p>
</li>
</ul>
<h3 id="1-2-MotionEvent和TouchSlop"><a href="#1-2-MotionEvent和TouchSlop" class="headerlink" title="1.2 MotionEvent和TouchSlop"></a>1.2 MotionEvent和TouchSlop</h3><h4 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h4><p>在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种：</p>
<ul>
<li>ACTION_DOWN—手指刚接触屏幕</li>
<li>ACTION_MOVE—手指在屏幕上移动</li>
<li>ACTION_UP—手指从屏幕上松开的一瞬间</li>
</ul>
<p>正常情况下，一次手指触碰屏幕的行为会触发<strong>一系列点击事件</strong>，通过MotionEvent对象我们可以得到点击事件发生的x和y坐标。为此，系统提供两种方法：getX/getY（返回相对于当前View左上角的x和y坐标）和getRawX/getRawY（返回的是相对于手机屏幕坐上角的x和y坐标）。</p>
<h4 id="TouchSlop"><a href="#TouchSlop" class="headerlink" title="TouchSlop"></a>TouchSlop</h4><p>TouchSlop是系统所能识别的被认为是滑动的最小距离，通过<code>ViewConfiguraion.get(getContext()).getScaledTouchSlop()</code>，即可以获得这个常量，==当我们处理滑动时，可以利用这个常量来做一些过滤。==</p>
<h3 id="1-3-VelocityTracker、GestureDetector和Scroller"><a href="#1-3-VelocityTracker、GestureDetector和Scroller" class="headerlink" title="1.3 VelocityTracker、GestureDetector和Scroller"></a>1.3 VelocityTracker、GestureDetector和Scroller</h3><ul>
<li>VelocityTracker测量出的是一段时间内，手指所划过的<strong>像素数</strong>，计算公式和用法如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">speed = (finalPosition - startPosition) / interval</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// initialing</span></div><div class="line">VelocityTracker velocityTracker = VelocityTracker.obtian();</div><div class="line"><span class="comment">// add event tracking</span></div><div class="line">velocityTracker.addMovement(event);</div><div class="line"><span class="comment">// before get speed, need to compute it(here the time interval is 1000ms)</span></div><div class="line">velocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</div><div class="line"><span class="comment">// after done it, and you can get velocityX/Y</span></div><div class="line"><span class="keyword">int</span> xVelocity = (<span class="keyword">int</span>) velocityTracker.getXVelocity();</div><div class="line"><span class="keyword">int</span> yVelocity = (<span class="keyword">int</span>) velocityTracker.getYVelocity();</div><div class="line"><span class="comment">// clear and recycle</span></div><div class="line">velocityTracker.clear();    <span class="comment">//一般在MotionEvent.ACTION_UP的时候调用</span></div><div class="line">velocityTracker.recycle();  <span class="comment">//一般在onDetachedFromWindow中调用</span></div></pre></td></tr></table></figure>
<ul>
<li>GestureDetector用于辅助检测用户的单击、滑动、长按、双击等行为。GestureDetector的使用比较简单，主要也是辅助检测常见的触屏事件。作者建议：如果只是监听滑动相关的事件就在onTouchEvent中自己实现；如果要监听双击这种行为的话，那么就使用GestureDetector。</li>
<li>Scroller<br>Scroller本身无法让View弹性滑动，它需要和View的computeScroller方法配合使用才能共同完成这个功能。典型代码如下<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Scroller scroller = <span class="keyword">new</span> Scroller(mcontext);</div><div class="line"></div><div class="line"><span class="comment">// 缓慢滑动到指定位置</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> scrollX = getScrollX();</div><div class="line">    <span class="keyword">int</span> delta = destX - scrollX;</div><div class="line">    <span class="comment">// 1000ms内滑向destX，效果就是慢慢滑动</span></div><div class="line">    mScroller.startScroll(scrollX, <span class="number">0</span>, delta, <span class="number">0</span>, <span class="number">1000</span>);</div><div class="line">    invalidata();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</div><div class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-View的滑动"><a href="#2-View的滑动" class="headerlink" title="2. View的滑动"></a>2. View的滑动</h2><h3 id="使用scrollTo-scrollBy"><a href="#使用scrollTo-scrollBy" class="headerlink" title="使用scrollTo/scrollBy"></a>使用scrollTo/scrollBy</h3><ul>
<li>scrollBy方法内部实际利用了scrollTo，它实现基于当前位置的相对滑动。</li>
<li>这两个方法实际移动不是View，而是画布本身，所以窗口是运动中的参照物。</li>
<li>这两个方式实际上是通过更改View内部两个属性mScrollX和mScrollY然后重绘视图。</li>
<li>在滑动过程中，mScrollX的值总是等于View左边缘和View内容左边缘在水平方向的距离。==View边缘是指View的位置，由四个顶点组成，而View内容边缘是指View中的内容的边缘，scrollTo/scrollBy这两个方法只能改变View内容的位置而不能改变View在布局中的位置。==</li>
<li>mScrollX/Y的值为：oldPosition - newPosition</li>
</ul>
<h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><ul>
<li>使用动画来移动view主要是操作view的translationX和translationY属性，既可以使用传统的view动画，也可以使用属性动画，使用后者需要考虑兼容性问题，如果要兼容Android 3.0以下版本系统的话推荐使用开源动画库<a href="http://nineoldandroids.com/" target="_blank" rel="external">nineoldandroids</a>。</li>
<li>View动画是对View的<strong>影像</strong>做操作，并不能真正改变View的位置参数，如果希望动画结束后的状态得以保存，必须将fillAfter属性设为true，否则动画结束后其动画结果会消失（即恢复原来的位置和状态）。</li>
<li>使用动画还存在一个交互问题：在android3.0以前的系统上，view动画和属性动画，新位置均无法触发点击事件，同时，老位置仍然可以触发单击事件。从3.0开始，属性动画的单击事件触发位置为移动后的位置，view动画仍然在原位置</li>
</ul>
<h3 id="改变布局参数"><a href="#改变布局参数" class="headerlink" title="改变布局参数"></a>改变布局参数</h3><p>通过改变View的LayoutParams参数，即可实现改变View的位置。</p>
<h2 id="3-弹性滑动"><a href="#3-弹性滑动" class="headerlink" title="3. 弹性滑动"></a>3. 弹性滑动</h2><ul>
<li><p>Scroller的工作原理：Scroller本身并不能实现view的滑动，它需要配合view的computeScroll方法才能完成弹性滑动的效果，它不断地让view重绘，而每一次重绘距滑动起始时间会有一个时间间隔，通过这个时间间隔Scroller就可以得出view的当前的滑动位置，知道了滑动位置就可以通过scrollTo方法来完成view的滑动。就这样，view的每一次重绘都会导致view进行小幅度的滑动，而多次的小幅度滑动就组成了弹性滑动，这就是Scroller的工作原理。</p>
</li>
<li><p>使用延时策略来实现弹性滑动，它的核心思想是通过发送一系列延时消息从而达到一种渐进式的效果，具体来说可以使用Handler的sendEmptyMessageDelayed(xxx)或view的postDelayed方法，也可以使用线程的sleep方法。</p>
</li>
</ul>
<h2 id="4-View的事件分发机制"><a href="#4-View的事件分发机制" class="headerlink" title="4. View的事件分发机制"></a>4. View的事件分发机制</h2><h3 id="4-1-点击事件的传递规则"><a href="#4-1-点击事件的传递规则" class="headerlink" title="4.1 点击事件的传递规则"></a>4.1 点击事件的传递规则</h3><ol>
<li><p>点击事件的分发过程由以下三个方法共同完成</p>
<ul>
<li>public boolean dispatchTouchEvent(MotionEvent ev)：用来进行事件的分发，如果事件能传递到当前View，那么此方法一定会被调用。返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent影响。</li>
<li>public boolean onTnterceptTouchEvent(MotionEvent ev)：如果当前View拦截了某个事件，那么同一个<strong>事件序列</strong>当中，此方法不会再被调用。</li>
<li>public boolean onTouchEvent(MotionEvent ev)：在dispatchTouchEvent中调用，用来处理点击事件。</li>
<li>以下伪代码能够详细的表示出它们的关系<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</div><div class="line">        consume = onTouchEvent(ev);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        consume = child.diapatchTouchEvent(event);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> consume;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果一个View设置了OntouchListener，那么它的onTouch将会被回调，而当前View的onTouchEvent调用与否取决于onTouch返回的是true还是false。平时我们给view设置的onClickListener的onClick方法调用在onTouchEvent中，所以它们的优先级是：OnTouchListener &gt; OnClickListener。</p>
</li>
<li>事件传递的一些结论：<ol>
<li>同一个事件序列是指以down事件开始，中间含有数量不等的move事件，最终以up事件结束。</li>
<li>正常情况下，一个事件序列只能被一个view拦截且消耗。</li>
<li>某个View一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序列能传递到的话，例如突然被父View拦截了，从而导致其无法收到后续，只能收到ACTION_CANCEL），并且他的onInterceptTouchEvent不会再被调用。</li>
<li>某个View一旦开始处理事件，如果它不消耗ACTION_DOWN（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给它来处理，并且将事件交给父元素的onTouchEvent来处理。</li>
<li>如果View不消耗除了ACTION_DOWN以外的其它事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</li>
<li>ViewGroup默认不拦截任何事件。源码中ViewGroup的onInterceptTouchEvent方法默认返回false。</li>
<li>View（特指单独View，而不是其子类ViewGroup）没有onInterceptTouchEvent方法,一旦有点击传递给它，那么它的onTouchEvent方法就会被调用。</li>
<li>View的onTouchEvent默认都会消耗事件，除非它是不可点击的（clickable和longClickable同时为false）。</li>
<li>View的enable属性不影响onTouchEvent返回值。那么它是disable状态，只要它是可点击的，那么它的onTouchEvent就返回true。</li>
<li>onClick会发生的前提是当前view是可点击的，并且它收到了down和up的事件。</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</li>
<li>ACTION_CANCEL事件是子View收到前驱事件后，后续事件被父控件拦截的情况下产生（例如在手指滑出子view范围，而它就会收到ACTION_CANCEL，而不是ACTION_UP），而它的后续事件（ACTION_MOVE &amp; UP会传递给它的父控件），onTouchEvent的事件回传到父控件只会发生在ACTION_DOWN事件中（这里可由iv和v得出），还有子View收到ACTION_CANCEL情况下的后续ACTION_MOVE 和 ACTION_UP。</li>
</ol>
</li>
</ol>
<h3 id="4-2-事件分发的源码解析"><a href="#4-2-事件分发的源码解析" class="headerlink" title="4.2 事件分发的源码解析"></a>4.2 事件分发的源码解析</h3><p>详细事件分发源码解析参考：<a href="http://blog.csdn.net/yanbober/article/details/45912661" target="_blank" rel="external">Android触摸屏事件派发机制详解与源码分析二(ViewGroup篇)</a></p>
<p>详细事件处理源码解析参考：<a href="http://blog.csdn.net/yanbober/article/details/45887547" target="_blank" rel="external">Android触摸屏事件派发机制详解与源码分析一(View篇)</a></p>
<h2 id="5-View的滑动冲突"><a href="#5-View的滑动冲突" class="headerlink" title="5. View的滑动冲突"></a>5. View的滑动冲突</h2><h3 id="5-1-常见的滑动冲突场景"><a href="#5-1-常见的滑动冲突场景" class="headerlink" title="5.1 常见的滑动冲突场景"></a>5.1 常见的滑动冲突场景</h3><ul>
<li>场景一————外部滑动方向和内部滑动方向<strong>不一致</strong>；</li>
<li>场景二————外部滑动方向和内部滑动方向<strong>一致</strong>；</li>
<li>场景三————上面两种情况的嵌套</li>
</ul>
<h3 id="5-2-解决方法"><a href="#5-2-解决方法" class="headerlink" title="5.2 解决方法"></a>5.2 解决方法</h3><ol>
<li><p>外部拦截法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 重写父容器的onInterceptTouchEvent</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">            <span class="keyword">if</span> ( 父容器需要当前事件 ) &#123;</div><div class="line">                intercepted = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                intercepted = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">            intercepted = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mLastXIntercept = x;</div><div class="line">        mLastYIntercept = y;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> intercepted;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>内部拦截法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 重写子元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</div><div class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">            parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</div><div class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</div><div class="line">            <span class="keyword">if</span> (父容器需要当前事件) &#123;</div><div class="line">                parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLastX = x;</div><div class="line">    mLastY = y;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不仅如此，父容器也需要修改</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> action = event.getAction();</div><div class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-View的基础知识&quot;&gt;&lt;a href=&quot;#1-View的基础知识&quot; class=&quot;headerlink&quot; title=&quot;1. View的基础知识&quot;&gt;&lt;/a&gt;1. View的基础知识&lt;/h2&gt;&lt;h3 id=&quot;1-1-View的位置参数&quot;&gt;&lt;a href=&quot;#1-
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="View" scheme="https://startwithwzk.github.io/tags/View/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>第二章 IPC机制（Inter-Process Communication）</title>
    <link href="https://startwithwzk.github.io/2017/07/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20IPC%E6%9C%BA%E5%88%B6%EF%BC%88Inter-Process%20Communication%EF%BC%89/"/>
    <id>https://startwithwzk.github.io/2017/07/22/第二章 IPC机制（Inter-Process Communication）/</id>
    <published>2017-07-22T15:22:00.000Z</published>
    <updated>2017-07-22T15:31:15.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h3><h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><ul>
<li>Serializable是Java提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。</li>
<li>想要一个对象序列化只需要这个类实现Serializable接口并声明一个serialVersionUID即可，实际上，不声明这个serialVersionUID同样可以实现序列化（因为系统会自动根据当前类结构生成hash值并赋值给serialVersionUID），但是这将会对反序列化产生影响。比如当反序列化时当前类有所改变，比如增加或者删除了某些成员变量，那么系统就会重新计算当前类的hash值，并把它赋值给serialVersionUID，这个时候当前类的serialVersionUID就和序列化的数据中的serialVersionUID不一致，于是反序列化失败，程序出现crash。相反，如果我们手动指定了其值，当反序列的时候，即使类结构有所改变，也可以最大限度的恢复数据，<strong>但是如果类结构发生了非常规性改变，例如修改了类名或成员变量的类型</strong>，这个时候即使通过了验证，反序列化还是失败。</li>
<li>静态成员变量属于类不属于对象，所以不会参与序列化过程</li>
<li>用transient关键字标记的成员变量不参与序列化过程。（transient译为短暂的）</li>
<li>系统的默认序列化过程是可以改变的，只需要重<code>writeObject()</code>和<code>readObject</code>方法即可。<h2 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h2></li>
<li><p>一个典型的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> userId;</div><div class="line">    <span class="keyword">public</span> String userName;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Book book;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, <span class="keyword">boolean</span> isMale)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.userId = userId;</div><div class="line">        <span class="keyword">this</span>.userName = userName;</div><div class="line">        <span class="keyword">this</span>.isMale = isMale;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">        userId = in.readInt();</div><div class="line">        userName = in.readString();</div><div class="line">        isMale = in.readByte() != <span class="number">0</span>;</div><div class="line">        <span class="comment">// book = in.readParcelable(Thread.currentThread().getContextClassLoader())</span></div><div class="line">        book = in.readParcelable(Book.class.getClassLoader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Creator&lt;User&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">        dest.writeInt(userId);</div><div class="line">        dest.writeString(userName);</div><div class="line">        dest.writeByte((<span class="keyword">byte</span>) (isMale ? <span class="number">1</span> : <span class="number">0</span>));</div><div class="line">        dest.writeParcelable(book, flags);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>特别需要注意的是在User(Parcel in)方法中，由于book是另一个可序列化对象，所以它的反序列化需要传递当前线程的上下文类加载器，否则会报无法找到类的错误。</p>
</li>
<li>Parcelable的方法说明</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>createFromParcel(Parcel in)</td>
<td>从序列化后的对象中创建原始对象</td>
</tr>
<tr>
<td>newArry(int size)</td>
<td>创建指定长度的原始对象数组</td>
</tr>
<tr>
<td>User(Parcel in)</td>
<td>从序列化后的对象中创建原始对象</td>
</tr>
<tr>
<td>writeToParcel(Parcel out, int flags)</td>
<td>将当前对象写入序列化结构中，其中flags有两种值：0 或者1。为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0</td>
</tr>
<tr>
<td>describeContents</td>
<td>返回当前对象的内容描述。如果含有文件描述符，返回1，否则返回0，几乎所有情况都返回0</td>
</tr>
</tbody>
</table>
<ul>
<li>虽然Serializable接口使用简单，但是起开销很大（需要大量的I/O操作）。而Parcelable是Android中的序列化方式，因此更适合用于Android平台上，也是Android推荐的序列化方式，虽然使用麻烦，但是它的效率很高。Parceable接口主要用于内存序列化上，Serializable主要用于将对象序列化到存储设备或者通过网络传输（这两种情况下，Parcelable稍显复杂）。</li>
</ul>
<h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><ul>
<li><p>概念</p>
<ol>
<li>直观来说，Binder是Android中的一个类，它实现了IBinder接口</li>
<li>从IPC角度，Binder是Android中的一种跨进程通信方式</li>
<li>Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux上没有</li>
<li>从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager等等）和相应ManagerService的桥梁</li>
<li>从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，<strong>这里的服务包括普通服务和基于ADIL的服务</strong></li>
</ol>
</li>
<li><p>aidl工具会根据aidl文件自动生成的java文件的解析：它继承了IInterface这个接口，同时他自己也还是个借口，所有需要在Binder中传输的<strong>接口</strong>都需要继承IInterface这个接口。首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。所以，这个接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：</p>
<ol>
<li>asInterface(android.os.IBinderobj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。</li>
<li>asBinder：返回当前Binder对象。</li>
<li>onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。这个方法的原型是<code>public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)</code>服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。</li>
<li>Proxy#[Method]：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC(远程过程调用)请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。</li>
</ol>
</li>
<li><p>Binder的两个重要方法linkToDeath和unlinkToDeath<br>Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。如何给Binder设置死亡代理呢？首先声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。其次在客户端绑定远程服务成功之后，给binder设置死亡代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mRemoteBookManager == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">        mRemoteBookManager = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span>这里重新绑定远程Service</span></div><div class="line">        <span class="comment">//此处的binder是重新绑定Service之后返回的Binder对象</span></div><div class="line">        binder.linkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Android中的IPC方式"><a href="#Android中的IPC方式" class="headerlink" title="Android中的IPC方式"></a>Android中的IPC方式</h3><h3 id="1-使用Bundle"><a href="#1-使用Bundle" class="headerlink" title="1. 使用Bundle"></a>1. 使用Bundle</h3><ul>
<li>由于Bundle实现了Parcelable接口，所以它可以方便地在不同进程之间传递。传输的数据必须能够被序列化，比如基本类型、实现了Parcelable接口的对象、实现了Serializable接口的对象以及一些Android支持的特殊对象。</li>
<li>一种特殊的应用场景，当A进程正在进行一个计算，计算完成后它要启动B进程的一个组件并把计算结果传递给它，但是遗憾的是计算结果并不能放入Bundle，因此无法使用Intent来传输，这个时候使用其他IPC方式就会略显复杂。可以考虑以下方式：通过Intent启动进程B的一个Service组件，让Service后台进行计算，计算完毕后再启动进程B中真正要启动的目标组件，由于Service也运行在进程B中，所以目标组件就可以直接获取计算结果，这样一来就轻松解决了。</li>
</ul>
<h3 id="2-使用文件共享"><a href="#2-使用文件共享" class="headerlink" title="2. 使用文件共享"></a>2. 使用文件共享</h3><ul>
<li>两个进程通过读/写同一个文件来交换数据。适合在对数据同步要求不高的进程之间进行通信。</li>
<li>SharedPreference是个特例，它通过键值对的方式存储文件，底层实现上就是采用的XML文件来存储键值对，每个应用的SharedPreference文件可以在/data/data/package name/shared_prefs目录下。虽然它也是一种文件，但是<strong>系统对它的读/写有一定的缓存策略</strong>，即在内存会有一份它的缓存，因此在多进程模式下，它就变得相当不可靠。所以不建议在进程间通过其共享数据。</li>
</ul>
<h3 id="3-使用Messenger"><a href="#3-使用Messenger" class="headerlink" title="3. 使用Messenger"></a>3. 使用Messenger</h3><ul>
<li>Messenger译为信使，它可以在不同进程中传递Message对象，是一种轻量化的IPC方案。它的底层实现是AIDL，只不过系统为我们做了封装从而方便上层调用。它是以<strong>串行</strong>的方式处理客户端发过来的消息。</li>
<li>Messenger和Message都实现了Parcelable接口，通过Messenger来传输Message，Message中能使用的载体只有what、arg1、arg2、Bundle以及replyTo。此外，还有一个object字段，在<strong>同一个进程</strong>中是很实用的，但是在进程间通信的时候，在Android2.2以前object字段不支持跨进程传输，即使是2.2以后，也仅仅是系统提供的实现了Parcelable接口的对象才能通过它来传输，自定义的对象是无法传输的，这也导致了object字段的实用性大大下降。</li>
<li>实现一个Messenger有以下几个步骤<h4 id="1-服务端进程"><a href="#1-服务端进程" class="headerlink" title="1. 服务端进程"></a>1. 服务端进程</h4>  首先需要在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。如<code>public IBinder onBind(Intent intent) { return mMessenger.getBinder(); }</code><h4 id="2-客户端进程中"><a href="#2-客户端进程中" class="headerlink" title="2.客户端进程中"></a>2.客户端进程中</h4>  首先需要绑定服务端的Service，绑定成功后用服务端返回的Ibinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送信息了，发消息类型为Message对象。如果需要服务端能够回应客户端，就和服务端一样，创建一个Handler并通过它创建一个新的Messenger，并把这个Messenger对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。如服务端获得传递过来的Messenger对象：<code>Messenger client = msg.replyTo;</code></li>
</ul>
<h3 id="4-使用AIDL"><a href="#4-使用AIDL" class="headerlink" title="4. 使用AIDL"></a>4. 使用AIDL</h3><p>使用AIDL可以实现跨进程的<strong>方法调用</strong>。主要是分为服务端和客户端两方面。</p>
<h4 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h4><p>首先要创建一个Service用于监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。</p>
<h4 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h4><p>首先绑定服务端的Service，绑定成功后用服务端返回的Ibinder对象转化成AIDL接口所属类型，接着就可以调用AIDL中的方法了。</p>
<h4 id="3-AIDL接口的创建"><a href="#3-AIDL接口的创建" class="headerlink" title="3. AIDL接口的创建"></a>3. AIDL接口的创建</h4><p>在AIDL文件中，只有6种数据类型得到支持。如下所示</p>
<ul>
<li>基本数据类型（int、long、char、boolean、double等）</li>
<li>String 和 CharSequence</li>
<li>List：只支持ArrayList，里面每个元素都必须能够被AIDL支持</li>
<li>Map：只支持HashMap，里面每个元素都必须能够被AIDL支持，包括key和value</li>
<li>Parcelable：所有实现了这个接口的对象</li>
<li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用</li>
</ul>
<p>特别需要注意的是</p>
<ol>
<li>自定义的Parcelable对象和AIDL对象必须要显式import进来，不管它们是否和当前AIDL文件位于同一个包中。</li>
<li>如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelable类型。</li>
<li>除了基本类型和接口之外，其它类型参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数，inout标志输入输出型参数，不能一概使用out或者inout，因为这在底层实现是有开销的。</li>
<li>AIDL接口中只支持方法，不支持声明静态常量</li>
<li>为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。</li>
<li>CopyOnWriteArrayList支持并发读/写</li>
<li>RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口。它的内部有一个Map结构专门用来保存所有的AIDL回调，这个Map的key是IBinder类型，value是Callback类型。另外它还有一个很有用的功能，就是当客户端进程终止后，它能够自动一处客户端所注册的listener，此外RemoteCallbackList内部自动实现了线程同步的功能。</li>
<li>当调用远程方法的时候，调用方会被挂起，此时，如果被调用方的方法是耗时的，就会导致调用方长时间地阻塞，又如果调用方调用方法时的线程是UI线程，将会导致ANR。</li>
</ol>
<h3 id="5-使用ContentProvider"><a href="#5-使用ContentProvider" class="headerlink" title="5. 使用ContentProvider"></a>5. 使用ContentProvider</h3><ul>
<li>底层实现是Binder</li>
<li>一个自定义的ContentProvider只需要继承并实现六个抽象方法即可。onCreate代表创建；getType用来返回一个Uri请求所对应的MIME类型（媒体类型）,比如图片、视频等，如果不关注这个，只需要返回null或者*/*。除了onCreate有系统回调并运行在主线程，其它方法都是由外界回调并运行在Binder线程池中。</li>
<li>ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；</li>
<li>ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；</li>
<li>ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；</li>
<li>要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；</li>
<li>ContentProvider还支持自定义调用，这个过程是通过ContentProvider和ContentResolver的Call方法来完成的。</li>
</ul>
<h3 id="6-使用Socket"><a href="#6-使用Socket" class="headerlink" title="6. 使用Socket"></a>6. 使用Socket</h3><ul>
<li>Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据报套接字两种，分别对应网络的传输控制层的TCP和UDP协议</li>
</ul>
<h2 id="Binder连接池"><a href="#Binder连接池" class="headerlink" title="Binder连接池"></a>Binder连接池</h2><ol>
<li><p>当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重量级，所以最好是将所有的AIDL放在同一个Service中去管理。</p>
</li>
<li><p>整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。</p>
</li>
<li><p>作者实现的Binder连接池<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_2/src/com/ryg/chapter_2/binderpool/BinderPool.java" target="_blank" rel="external">BinderPool</a>的实现源码，建议在AIDL开发工作中引入BinderPool机制。</p>
</li>
</ol>
<h3 id="IPC方式的优缺点和适用场景"><a href="#IPC方式的优缺点和适用场景" class="headerlink" title="IPC方式的优缺点和适用场景"></a>IPC方式的优缺点和适用场景</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://hujiaweibujidao.github.io/images/androidart_ipc.png?_=5028970" alt="IPC方式的优缺点和适用场景" title="">
                </div>
                <div class="image-caption">IPC方式的优缺点和适用场景</div>
            </figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IPC基础概念介绍&quot;&gt;&lt;a href=&quot;#IPC基础概念介绍&quot; class=&quot;headerlink&quot; title=&quot;IPC基础概念介绍&quot;&gt;&lt;/a&gt;IPC基础概念介绍&lt;/h3&gt;&lt;h3 id=&quot;Serializable接口&quot;&gt;&lt;a href=&quot;#Serializabl
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>第二章 Android中的多进程模式</title>
    <link href="https://startwithwzk.github.io/2017/07/22/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20Android%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://startwithwzk.github.io/2017/07/22/第二章 Android中的多进程模式/</id>
    <published>2017-07-22T15:20:00.000Z</published>
    <updated>2017-07-22T15:31:40.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h2><h3 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h3><ul>
<li>通常情况下，在Android中的多进程指的是一个应用存在多个进程，而不是指的是两个应用之间的多进程通信。</li>
<li>在Android中使用多进程只有一种方法，就是给四大组件（Activity、Service、Receiver、ContentProvider）在AndroidManifest中指定<code>android:process</code>属性，也就是说无法给一个线程或者一个实体类指定其运行时所在线程。<em>Ps:其实还有一种非常规方法，那就是通过JNI（Java Native Interface）在native层去fork一个新的进程。</em></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span></span></div><div class="line">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></div><div class="line">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></div><div class="line">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span> </span></div><div class="line">                  <span class="attr">android:process</span>=<span class="string">":remote"</span>/&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".ThirdActivity"</span></span></div><div class="line">                  <span class="attr">android:process</span>=<span class="string">"com.example.ricco.myapplication.remote"</span> /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://i1.piimg.com/567571/3ac137dd8d27ed69.png" alt="进程名" title="">
                </div>
                <div class="image-caption">进程名</div>
            </figure>
<p>上方代码和图片分别描述了如何在Android中创建多进程，其中MainActivity没有指定<code>android:process</code>属性，那么它运行在默认进程中，默认进程名为包名。而另外两个分别指定了“<code>:remote</code>”和“<code>com.example.ricco.myapplication.remote</code>”，首先，“：”的含义是==指要在当前进程名前面附加上当前的包名==，而对于ThirdActivity中的声明方式，它是一种完整的命名方式，不会附加包名信息；其次，进程名以“：”开头的进程属于当前应用的私有进程，其他应用组件不可以和它跑在同一个进程中，而其他进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一进程中。</p>
<ul>
<li>Android会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。两个应用通过ShareUID跑在同一个进程中时，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，不管它们是否跑在同一个进程中，它们可以互相访问对方的私有数据（data目录，组件信息等），如果它们跑在同一进程中，还可以共享内存数据，或者说它们看起来像是一个应用的两个部分。==其实可以这样理解同一个应用间的多进程：它就相当于两个不同的应用采用了ShareUID的模式==<h3 id="多进程模式的运行机制"><a href="#多进程模式的运行机制" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h3></li>
<li>Android会为每一个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同虚拟机在内存分配上有不同的地址空间。</li>
<li>一般来说使用多进程会造成如下几方面的问题：<ol>
<li>静态成员和单例模式完全失效</li>
<li>线程同步机制完全失效</li>
<li>SharePreference的可靠性下降（SharePreference底层是通过读/写XML文件来实现的，并发读写可能会出现问题）</li>
<li>Application会多次创建（运行在同一个进程中的组件属于同一个虚拟机和同一个Application，所以运行在不同进程中组件是属于两个不同的虚拟机和Application的）</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android中的多进程模式&quot;&gt;&lt;a href=&quot;#Android中的多进程模式&quot; class=&quot;headerlink&quot; title=&quot;Android中的多进程模式&quot;&gt;&lt;/a&gt;Android中的多进程模式&lt;/h2&gt;&lt;h3 id=&quot;开启多进程模式&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>第一章 Activity的生命周期与启动模式</title>
    <link href="https://startwithwzk.github.io/2017/07/22/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://startwithwzk.github.io/2017/07/22/第一章 Activity的生命周期与启动模式/</id>
    <published>2017-07-22T15:14:00.000Z</published>
    <updated>2017-07-22T15:33:15.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="典型情况下的生命周期分析"><a href="#典型情况下的生命周期分析" class="headerlink" title="典型情况下的生命周期分析"></a>典型情况下的生命周期分析</h3><ul>
<li>onStart：此时表示Activity正在启动，可以理解为已经可见了，但是还没有出现在<strong>前台</strong>，还无法与用户交互，即其已经出现，只是用户还看不见。</li>
<li>onResume：表示Activity已经出现在<strong>前台</strong>并开始活动。</li>
<li>onPause：此时可以做一些停止动画，储存数据等工作，但是不能太耗时间，因为这会影响新Activity的显示，==旧Activity的onPause方法执行完毕，新Activity的才开始启动。==</li>
<li>onStop：表示Activity即将停止，可以做一些稍微重量级的回收工作。<h3 id="异常情况下生命周期分析"><a href="#异常情况下生命周期分析" class="headerlink" title="异常情况下生命周期分析"></a>异常情况下生命周期分析</h3></li>
<li>当系统配置发生改变的时候，系统会调用<code>onSaveInstance</code>来保存当前Activity的状态，这个方式调用时机是在<code>onStop</code>之前，与<code>onPause</code>没有特定的关系，有时会在它之前，有时在它之后；当Activity被重建的时候，系统会调用<code>onRestoreInstance</code>，并且会把<code>onSaveInstance</code>方法所保存的<code>Bundle</code>对象传递给<code>onCreate</code>和<code>onRestoreInstance</code>，从时序上说，<code>onRestoreInstance</code>的调用时机在<code>onStart</code>之后。</li>
<li>虽然两种方法都可以恢复数据，但是正常启动的时候<code>onCreate</code>的参数为<code>null</code>，必须要添加额外判断，而<code>onRestoreInstance</code>方法一旦被调用，其参数必定有值。官网文档建议是采用<code>onRestoreInstance</code>去恢复数据。</li>
<li>每个View都有<code>onSaveInstance</code>和<code>onRestoreInstance</code>这两个方法，可以看一下它们的具体实现，就可以知道它们在系统配置变化时会自动恢复哪一些数据。</li>
<li>可以通过指定Activity的<code>configChanges</code>属性来避免特定属性改变导致的重建，取而代之是系统会调用<code>onConfigurationChanged</code>,这是就可以做一些特殊处理；我们平时常用的有locale（系统本地位置，一般指系统语言）、orientation（屏幕方向发生改变）、keyboardHidden（键盘访问性发生了改变）<h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><h3 id="LaunchMode"><a href="#LaunchMode" class="headerlink" title="LaunchMode"></a>LaunchMode</h3></li>
<li>standard：每启动一个Activity就会重新创建一个实例，==谁启动就运行在谁的任务栈中==，此外特别注意一点，当用<code>ApplicationContext</code>去启动standard模式Activity的时候会报错，因为其不是Activity类型的Context，所以不具有任务栈，解决方式就是设定<code>FLAG_ACTIVITY_NEW_TASK</code>标志位，这个时候启动Activity实际上是以singleTask模式启动的。</li>
<li>singleTop：栈顶复用模式，如果位于任务栈栈顶就不会再次创建，同时，<code>onNewIntent</code>方法会被回调。</li>
<li>singleTask：栈内复用模式。只要特定Activity在一个栈中存在就不会创建，此外如果在所有栈中都不存在就会创建一个任务栈，并创建一个实例放入其中。</li>
<li>singleInstance：单实例模式。具有这种模式的Activity只能单独位于一个任务栈中。</li>
<li>当<code>TaskAffinity</code>和singleTask配合使用的时候，待启动的Activity会运行在名字和<code>TaskAffinity</code>相同的任务栈中。</li>
<li>当<code>allowTaskReparenting</code>属性为true的时候，此Activity可以被重定向。<h3 id="IntentFilter"><a href="#IntentFilter" class="headerlink" title="IntentFilter"></a>IntentFilter</h3></li>
<li>原则上一个Intent不应该既是显式调用又是隐式调用，如果共存以显式为准。</li>
<li>一个Activity中可以有多个<code>&lt;intent-filter&gt;</code>，一个Intent只要能匹配任何一组<code>&lt;intent-filter&gt;</code>即可成功启动。</li>
<li>要想匹配成功，action是要求Intent中必须要有一个action则必须能够和过滤规则中的某个action相同，data也是类似。此外当存在category的时候，每个都必须能够和过滤规则中任何一个category相同。</li>
<li>如果Intent不设置category，当启动的时候，系统会默认添加<code>android.intent.category.DEFAULT</code>这个category。</li>
<li>category中不含有<code>android.intent.category.DEFAULT</code>的Activity是无法接收隐式Intent的。</li>
<li>data由mimeType与URI两部分组成，mimeType指媒体类型（image/jpeg、audio/mpeg4-generic、video/*等）,URI结构：`<scheme>://<host>:<port>/[<path></path>|<pathprefix>|<pathpattern>]，==当URI中scheme或者host未指定，则意味着此URI无效。==</pathpattern></pathprefix></port></host></scheme></li>
<li>如果需要为intent指定完整的data，必须要调用<code>setDataAndType</code>方法，不能先调用<code>setData</code>再调用<code>setType</code>，因为这两个方法会彼此清除对方的值。<h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4>当通过隐式方法启动Activity的时候，可以通过PackageManager或者Intent的<code>resolveActivity</code>方法查找匹配的Activity，找不到返回<code>null</code>。此外，PackageManager还提供<code>queryIntentActivity</code>方法，这个方法与<code>resolveActivity</code>不同的是，它不是返回<strong>最佳匹配</strong>的Activity，而是返回<strong>所有成功匹配</strong>的Activity信息。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h2&gt;&lt;h3 id=&quot;典型情况下的生命周期分析&quot;&gt;&lt;a href=&quot;#典型情况下的生命周期分析&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="读书笔记" scheme="https://startwithwzk.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="https://startwithwzk.github.io/tags/Android/"/>
    
      <category term="Android开发艺术探索" scheme="https://startwithwzk.github.io/tags/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>UML类图几种关系总结</title>
    <link href="https://startwithwzk.github.io/2017/07/22/UML%E7%B1%BB%E5%9B%BE%E5%87%A0%E7%A7%8D%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93/"/>
    <id>https://startwithwzk.github.io/2017/07/22/UML类图几种关系总结/</id>
    <published>2017-07-22T14:33:52.000Z</published>
    <updated>2017-07-22T14:51:00.880Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在UML类图中，常见的有以下几种关系：泛化（Generalization），实现（Realization），关联（Association），聚合（Aggregation），组合(Composition)，依赖(Dependency)</p>
</blockquote>
<h2 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h2><p>【泛化关系】：是一种<strong>继承</strong>关系，它指定了子类如何特别化父类的所有特征和行为。例如：老虎是动物的一种。<br>【箭头指向】：带三角箭头的实线，箭头指向父类。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://hi.csdn.net/attachment/201104/22/0_1303436788Qi60.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h2><p>【实现关系】：是一种类于接口的关系，表示类是接口所有特性和行为的实现<br>【箭头指向】：带三角箭头的虚线，箭头指向接口</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://hi.csdn.net/attachment/201104/22/0_13034367939K49.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h2><p>【关联关系】：是一种拥有关系，它使一个类知道另一个类的属性和方法。关联可以使双向的，也可以使单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。如：老师与学生、学生与课程<br>【代码体现】：成员变量<br>【箭头指向】：带普通箭头的实心线，指向被拥有者</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://hi.csdn.net/attachment/201104/22/0_1303436801W1kf.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。</p>
<h2 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h2><p>【聚合关系】：是整体与部分的关系。聚合关系是关联关系的一种，是<strong>强的关联关系</strong>。并且关联和聚合在<strong>语法</strong>上无法区分，必须考察具体的逻辑关系。如：车和轮胎<br>【代码体现】：成员变量<br>【箭头指向】：带空心菱形的实心线，菱形指向整体</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://hi.csdn.net/attachment/201104/22/0_1303436811y36B.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h2><p>【组合关系】：是整体与部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期<br>【代码体现】：成员变量<br>【箭头指向】：带实心菱形的实线，菱形指向整体</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://hi.csdn.net/attachment/201104/22/0_1303436817mqXK.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h2><p>【依赖关系】：是一种使用的关系,所以要尽量不使用双向的互相依赖。<br>【代码表现】：局部变量、方法的参数或者对静态方法的调用<br>【箭头及指向】：带箭头的虚线，指向被使用者</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://hi.csdn.net/attachment/201104/22/0_130343682580L6.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<hr>
<p>各种关系的强弱顺序：<strong>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong></p>
<p>下面这张UML图，比较形象地展示了各种类图的关系：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://hi.csdn.net/attachment/201202/29/0_1330497855hqk2.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在UML类图中，常见的有以下几种关系：泛化（Generalization），实现（Realization），关联（Association），聚合（Aggregation），组合(Composition)，依赖(Dependency)&lt;/p&gt;
&lt;/b
    
    </summary>
    
    
      <category term="UML" scheme="https://startwithwzk.github.io/tags/UML/"/>
    
  </entry>
  
</feed>
